# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-05-02T11:43:37.606
# original file: /home/kshpthk/controller/proto/acl.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export AclLogActionEnum, AclMatch, AclForwardActionEnum, AclRuleTypeEnum, AclAction
export AclEntry, AclRuleSet


@enumx AclLogActionEnum ACLLOGACTION_UNDEFINED=0 ACLLOGACTION_NOLOG=1 ACLLOGACTION_SYSLOG=2

struct AclMatch
    dscp::UInt32
    protocol::UInt32
    src_address::String
    dst_address::String
    src_port::UInt32
    dst_port::UInt32
    start_mpls_label::UInt32
    end_mpls_label::UInt32
    tcp_flags::String
end
PB.default_values(::Type{AclMatch}) = (;dscp = zero(UInt32), protocol = zero(UInt32), src_address = "", dst_address = "", src_port = zero(UInt32), dst_port = zero(UInt32), start_mpls_label = zero(UInt32), end_mpls_label = zero(UInt32), tcp_flags = "")
PB.field_numbers(::Type{AclMatch}) = (;dscp = 1, protocol = 2, src_address = 3, dst_address = 4, src_port = 5, dst_port = 6, start_mpls_label = 7, end_mpls_label = 8, tcp_flags = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AclMatch})
    dscp = zero(UInt32)
    protocol = zero(UInt32)
    src_address = ""
    dst_address = ""
    src_port = zero(UInt32)
    dst_port = zero(UInt32)
    start_mpls_label = zero(UInt32)
    end_mpls_label = zero(UInt32)
    tcp_flags = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            dscp = PB.decode(d, UInt32)
        elseif field_number == 2
            protocol = PB.decode(d, UInt32)
        elseif field_number == 3
            src_address = PB.decode(d, String)
        elseif field_number == 4
            dst_address = PB.decode(d, String)
        elseif field_number == 5
            src_port = PB.decode(d, UInt32)
        elseif field_number == 6
            dst_port = PB.decode(d, UInt32)
        elseif field_number == 7
            start_mpls_label = PB.decode(d, UInt32)
        elseif field_number == 8
            end_mpls_label = PB.decode(d, UInt32)
        elseif field_number == 9
            tcp_flags = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return AclMatch(dscp, protocol, src_address, dst_address, src_port, dst_port, start_mpls_label, end_mpls_label, tcp_flags)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AclMatch)
    initpos = position(e.io)
    x.dscp != zero(UInt32) && PB.encode(e, 1, x.dscp)
    x.protocol != zero(UInt32) && PB.encode(e, 2, x.protocol)
    !isempty(x.src_address) && PB.encode(e, 3, x.src_address)
    !isempty(x.dst_address) && PB.encode(e, 4, x.dst_address)
    x.src_port != zero(UInt32) && PB.encode(e, 5, x.src_port)
    x.dst_port != zero(UInt32) && PB.encode(e, 6, x.dst_port)
    x.start_mpls_label != zero(UInt32) && PB.encode(e, 7, x.start_mpls_label)
    x.end_mpls_label != zero(UInt32) && PB.encode(e, 8, x.end_mpls_label)
    !isempty(x.tcp_flags) && PB.encode(e, 9, x.tcp_flags)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AclMatch)
    encoded_size = 0
    x.dscp != zero(UInt32) && (encoded_size += PB._encoded_size(x.dscp, 1))
    x.protocol != zero(UInt32) && (encoded_size += PB._encoded_size(x.protocol, 2))
    !isempty(x.src_address) && (encoded_size += PB._encoded_size(x.src_address, 3))
    !isempty(x.dst_address) && (encoded_size += PB._encoded_size(x.dst_address, 4))
    x.src_port != zero(UInt32) && (encoded_size += PB._encoded_size(x.src_port, 5))
    x.dst_port != zero(UInt32) && (encoded_size += PB._encoded_size(x.dst_port, 6))
    x.start_mpls_label != zero(UInt32) && (encoded_size += PB._encoded_size(x.start_mpls_label, 7))
    x.end_mpls_label != zero(UInt32) && (encoded_size += PB._encoded_size(x.end_mpls_label, 8))
    !isempty(x.tcp_flags) && (encoded_size += PB._encoded_size(x.tcp_flags, 9))
    return encoded_size
end

@enumx AclForwardActionEnum ACLFORWARDINGACTION_UNDEFINED=0 ACLFORWARDINGACTION_DROP=1 ACLFORWARDINGACTION_ACCEPT=2 ACLFORWARDINGACTION_REJECT=3

@enumx AclRuleTypeEnum ACLRULETYPE_UNDEFINED=0 ACLRULETYPE_IPV4=1 ACLRULETYPE_IPV6=2 ACLRULETYPE_L2=3 ACLRULETYPE_MPLS=4 ACLRULETYPE_MIXED=5

struct AclAction
    forward_action::AclForwardActionEnum.T
    log_action::AclLogActionEnum.T
end
PB.default_values(::Type{AclAction}) = (;forward_action = AclForwardActionEnum.ACLFORWARDINGACTION_UNDEFINED, log_action = AclLogActionEnum.ACLLOGACTION_UNDEFINED)
PB.field_numbers(::Type{AclAction}) = (;forward_action = 1, log_action = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AclAction})
    forward_action = AclForwardActionEnum.ACLFORWARDINGACTION_UNDEFINED
    log_action = AclLogActionEnum.ACLLOGACTION_UNDEFINED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            forward_action = PB.decode(d, AclForwardActionEnum.T)
        elseif field_number == 2
            log_action = PB.decode(d, AclLogActionEnum.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return AclAction(forward_action, log_action)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AclAction)
    initpos = position(e.io)
    x.forward_action != AclForwardActionEnum.ACLFORWARDINGACTION_UNDEFINED && PB.encode(e, 1, x.forward_action)
    x.log_action != AclLogActionEnum.ACLLOGACTION_UNDEFINED && PB.encode(e, 2, x.log_action)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AclAction)
    encoded_size = 0
    x.forward_action != AclForwardActionEnum.ACLFORWARDINGACTION_UNDEFINED && (encoded_size += PB._encoded_size(x.forward_action, 1))
    x.log_action != AclLogActionEnum.ACLLOGACTION_UNDEFINED && (encoded_size += PB._encoded_size(x.log_action, 2))
    return encoded_size
end

struct AclEntry
    sequence_id::UInt32
    description::String
    match::Union{Nothing,AclMatch}
    action::Union{Nothing,AclAction}
end
PB.default_values(::Type{AclEntry}) = (;sequence_id = zero(UInt32), description = "", match = nothing, action = nothing)
PB.field_numbers(::Type{AclEntry}) = (;sequence_id = 1, description = 2, match = 3, action = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AclEntry})
    sequence_id = zero(UInt32)
    description = ""
    match = Ref{Union{Nothing,AclMatch}}(nothing)
    action = Ref{Union{Nothing,AclAction}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            sequence_id = PB.decode(d, UInt32)
        elseif field_number == 2
            description = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, match)
        elseif field_number == 4
            PB.decode!(d, action)
        else
            PB.skip(d, wire_type)
        end
    end
    return AclEntry(sequence_id, description, match[], action[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AclEntry)
    initpos = position(e.io)
    x.sequence_id != zero(UInt32) && PB.encode(e, 1, x.sequence_id)
    !isempty(x.description) && PB.encode(e, 2, x.description)
    !isnothing(x.match) && PB.encode(e, 3, x.match)
    !isnothing(x.action) && PB.encode(e, 4, x.action)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AclEntry)
    encoded_size = 0
    x.sequence_id != zero(UInt32) && (encoded_size += PB._encoded_size(x.sequence_id, 1))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 2))
    !isnothing(x.match) && (encoded_size += PB._encoded_size(x.match, 3))
    !isnothing(x.action) && (encoded_size += PB._encoded_size(x.action, 4))
    return encoded_size
end

struct AclRuleSet
    name::String
    var"#type"::AclRuleTypeEnum.T
    description::String
    user_id::String
    entries::Vector{AclEntry}
end
PB.default_values(::Type{AclRuleSet}) = (;name = "", var"#type" = AclRuleTypeEnum.ACLRULETYPE_UNDEFINED, description = "", user_id = "", entries = Vector{AclEntry}())
PB.field_numbers(::Type{AclRuleSet}) = (;name = 1, var"#type" = 2, description = 3, user_id = 4, entries = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AclRuleSet})
    name = ""
    var"#type" = AclRuleTypeEnum.ACLRULETYPE_UNDEFINED
    description = ""
    user_id = ""
    entries = PB.BufferedVector{AclEntry}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            var"#type" = PB.decode(d, AclRuleTypeEnum.T)
        elseif field_number == 3
            description = PB.decode(d, String)
        elseif field_number == 4
            user_id = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, entries)
        else
            PB.skip(d, wire_type)
        end
    end
    return AclRuleSet(name, var"#type", description, user_id, entries[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AclRuleSet)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    x.var"#type" != AclRuleTypeEnum.ACLRULETYPE_UNDEFINED && PB.encode(e, 2, x.var"#type")
    !isempty(x.description) && PB.encode(e, 3, x.description)
    !isempty(x.user_id) && PB.encode(e, 4, x.user_id)
    !isempty(x.entries) && PB.encode(e, 5, x.entries)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AclRuleSet)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    x.var"#type" != AclRuleTypeEnum.ACLRULETYPE_UNDEFINED && (encoded_size += PB._encoded_size(x.var"#type", 2))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 3))
    !isempty(x.user_id) && (encoded_size += PB._encoded_size(x.user_id, 4))
    !isempty(x.entries) && (encoded_size += PB._encoded_size(x.entries, 5))
    return encoded_size
end
