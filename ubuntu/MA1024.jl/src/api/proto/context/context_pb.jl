# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-05-02T11:43:37.606
# original file: /home/kshpthk/controller/proto/context.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Timestamp, ConnectionSettings_L0, DeviceOperationalStatusEnum, ConfigRule_Custom
export LinkTypeEnum, OpticalLinkDetails, ConnectionSettings_L4, Uuid, Constraint_Custom
export GPS_Position, ServiceStatusEnum, SliceStatusEnum, ConnectionSettings_L3
export Constraint_SLA_Capacity, LinkAttributes, Constraint_Schedule, ConfigActionEnum
export IsolationLevelEnum, Constraint_SLA_Latency, ConnectionSettings_L2, OpticalConfigId
export ServiceTypeEnum, ConstraintActionEnum, Constraint_SLA_Availability, Empty
export DeviceDriverEnum, EventTypeEnum, DeviceId, LinkId, ContextId, ConnectionId
export SliceOwner, QoSProfileId, Component, Location, ServiceStatus, SliceStatus
export Constraint_SLA_Isolation_level, ConnectionSettings, Event, OpticalConfig
export DeviceIdList, OpticalEndPointId, LinkIdList, TopologyId, ServiceId
export TeraFlowController, AuthenticationResult, ContextIdList, SliceId, ConnectionIdList
export Constraint_QoSProfile, ConnectionEvent, ContextEvent, LinkEvent, OpticalConfigEvent
export OpticalConfigList, DeviceFilter, TopologyIdList, TopologyEvent, EndPointId, Topology
export ServiceEvent, ServiceConfigRule, ServiceIdList, Context, SliceIdList, SliceEvent
export EndPointName, Link, Constraint_Exclusions, Constraint_EndPointPriority, EndPoint
export Constraint_EndPointLocation, OpticalLink, EndPointIdList, ConfigRule_ACL, Connection
export TopologyList, ServiceFilter, ContextList, SliceFilter, EndPointNameList, LinkList
export Constraint, OpticalLinkList, ConfigRule, ConnectionList, SliceConfig, DeviceConfig
export ServiceConfig, Slice, DeviceEvent, Device, Service, SliceList, DeviceList
export TopologyDetails, ServiceList, ContextService


struct Timestamp
    timestamp::Float64
end
PB.default_values(::Type{Timestamp}) = (;timestamp = zero(Float64))
PB.field_numbers(::Type{Timestamp}) = (;timestamp = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Timestamp})
    timestamp = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            timestamp = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Timestamp(timestamp)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Timestamp)
    initpos = position(e.io)
    x.timestamp !== zero(Float64) && PB.encode(e, 1, x.timestamp)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Timestamp)
    encoded_size = 0
    x.timestamp !== zero(Float64) && (encoded_size += PB._encoded_size(x.timestamp, 1))
    return encoded_size
end

struct ConnectionSettings_L0
    lsp_symbolic_name::String
end
PB.default_values(::Type{ConnectionSettings_L0}) = (;lsp_symbolic_name = "")
PB.field_numbers(::Type{ConnectionSettings_L0}) = (;lsp_symbolic_name = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionSettings_L0})
    lsp_symbolic_name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            lsp_symbolic_name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionSettings_L0(lsp_symbolic_name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionSettings_L0)
    initpos = position(e.io)
    !isempty(x.lsp_symbolic_name) && PB.encode(e, 1, x.lsp_symbolic_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionSettings_L0)
    encoded_size = 0
    !isempty(x.lsp_symbolic_name) && (encoded_size += PB._encoded_size(x.lsp_symbolic_name, 1))
    return encoded_size
end

@enumx DeviceOperationalStatusEnum DEVICEOPERATIONALSTATUS_UNDEFINED=0 DEVICEOPERATIONALSTATUS_DISABLED=1 DEVICEOPERATIONALSTATUS_ENABLED=2

struct ConfigRule_Custom
    resource_key::String
    resource_value::String
end
PB.default_values(::Type{ConfigRule_Custom}) = (;resource_key = "", resource_value = "")
PB.field_numbers(::Type{ConfigRule_Custom}) = (;resource_key = 1, resource_value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConfigRule_Custom})
    resource_key = ""
    resource_value = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            resource_key = PB.decode(d, String)
        elseif field_number == 2
            resource_value = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConfigRule_Custom(resource_key, resource_value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConfigRule_Custom)
    initpos = position(e.io)
    !isempty(x.resource_key) && PB.encode(e, 1, x.resource_key)
    !isempty(x.resource_value) && PB.encode(e, 2, x.resource_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConfigRule_Custom)
    encoded_size = 0
    !isempty(x.resource_key) && (encoded_size += PB._encoded_size(x.resource_key, 1))
    !isempty(x.resource_value) && (encoded_size += PB._encoded_size(x.resource_value, 2))
    return encoded_size
end

@enumx LinkTypeEnum LINKTYPE_UNKNOWN=0 LINKTYPE_COPPER=1 LINKTYPE_VIRTUAL_COPPER=2 LINKTYPE_OPTICAL=3 LINKTYPE_VIRTUAL_OPTICAL=4

struct OpticalLinkDetails
    length::Float32
    src_port::String
    dst_port::String
    local_peer_port::String
    remote_peer_port::String
    used::Bool
    c_slots::Dict{String,Int32}
    l_slots::Dict{String,Int32}
    s_slots::Dict{String,Int32}
end
PB.default_values(::Type{OpticalLinkDetails}) = (;length = zero(Float32), src_port = "", dst_port = "", local_peer_port = "", remote_peer_port = "", used = false, c_slots = Dict{String,Int32}(), l_slots = Dict{String,Int32}(), s_slots = Dict{String,Int32}())
PB.field_numbers(::Type{OpticalLinkDetails}) = (;length = 1, src_port = 2, dst_port = 3, local_peer_port = 4, remote_peer_port = 5, used = 6, c_slots = 7, l_slots = 8, s_slots = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalLinkDetails})
    length = zero(Float32)
    src_port = ""
    dst_port = ""
    local_peer_port = ""
    remote_peer_port = ""
    used = false
    c_slots = Dict{String,Int32}()
    l_slots = Dict{String,Int32}()
    s_slots = Dict{String,Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            length = PB.decode(d, Float32)
        elseif field_number == 2
            src_port = PB.decode(d, String)
        elseif field_number == 3
            dst_port = PB.decode(d, String)
        elseif field_number == 4
            local_peer_port = PB.decode(d, String)
        elseif field_number == 5
            remote_peer_port = PB.decode(d, String)
        elseif field_number == 6
            used = PB.decode(d, Bool)
        elseif field_number == 7
            PB.decode!(d, c_slots)
        elseif field_number == 8
            PB.decode!(d, l_slots)
        elseif field_number == 9
            PB.decode!(d, s_slots)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalLinkDetails(length, src_port, dst_port, local_peer_port, remote_peer_port, used, c_slots, l_slots, s_slots)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalLinkDetails)
    initpos = position(e.io)
    x.length !== zero(Float32) && PB.encode(e, 1, x.length)
    !isempty(x.src_port) && PB.encode(e, 2, x.src_port)
    !isempty(x.dst_port) && PB.encode(e, 3, x.dst_port)
    !isempty(x.local_peer_port) && PB.encode(e, 4, x.local_peer_port)
    !isempty(x.remote_peer_port) && PB.encode(e, 5, x.remote_peer_port)
    x.used != false && PB.encode(e, 6, x.used)
    !isempty(x.c_slots) && PB.encode(e, 7, x.c_slots)
    !isempty(x.l_slots) && PB.encode(e, 8, x.l_slots)
    !isempty(x.s_slots) && PB.encode(e, 9, x.s_slots)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalLinkDetails)
    encoded_size = 0
    x.length !== zero(Float32) && (encoded_size += PB._encoded_size(x.length, 1))
    !isempty(x.src_port) && (encoded_size += PB._encoded_size(x.src_port, 2))
    !isempty(x.dst_port) && (encoded_size += PB._encoded_size(x.dst_port, 3))
    !isempty(x.local_peer_port) && (encoded_size += PB._encoded_size(x.local_peer_port, 4))
    !isempty(x.remote_peer_port) && (encoded_size += PB._encoded_size(x.remote_peer_port, 5))
    x.used != false && (encoded_size += PB._encoded_size(x.used, 6))
    !isempty(x.c_slots) && (encoded_size += PB._encoded_size(x.c_slots, 7))
    !isempty(x.l_slots) && (encoded_size += PB._encoded_size(x.l_slots, 8))
    !isempty(x.s_slots) && (encoded_size += PB._encoded_size(x.s_slots, 9))
    return encoded_size
end

struct ConnectionSettings_L4
    src_port::UInt32
    dst_port::UInt32
    tcp_flags::UInt32
    ttl::UInt32
end
PB.default_values(::Type{ConnectionSettings_L4}) = (;src_port = zero(UInt32), dst_port = zero(UInt32), tcp_flags = zero(UInt32), ttl = zero(UInt32))
PB.field_numbers(::Type{ConnectionSettings_L4}) = (;src_port = 1, dst_port = 2, tcp_flags = 3, ttl = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionSettings_L4})
    src_port = zero(UInt32)
    dst_port = zero(UInt32)
    tcp_flags = zero(UInt32)
    ttl = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            src_port = PB.decode(d, UInt32)
        elseif field_number == 2
            dst_port = PB.decode(d, UInt32)
        elseif field_number == 3
            tcp_flags = PB.decode(d, UInt32)
        elseif field_number == 4
            ttl = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionSettings_L4(src_port, dst_port, tcp_flags, ttl)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionSettings_L4)
    initpos = position(e.io)
    x.src_port != zero(UInt32) && PB.encode(e, 1, x.src_port)
    x.dst_port != zero(UInt32) && PB.encode(e, 2, x.dst_port)
    x.tcp_flags != zero(UInt32) && PB.encode(e, 3, x.tcp_flags)
    x.ttl != zero(UInt32) && PB.encode(e, 4, x.ttl)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionSettings_L4)
    encoded_size = 0
    x.src_port != zero(UInt32) && (encoded_size += PB._encoded_size(x.src_port, 1))
    x.dst_port != zero(UInt32) && (encoded_size += PB._encoded_size(x.dst_port, 2))
    x.tcp_flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.tcp_flags, 3))
    x.ttl != zero(UInt32) && (encoded_size += PB._encoded_size(x.ttl, 4))
    return encoded_size
end

struct Uuid
    uuid::String
end
PB.default_values(::Type{Uuid}) = (;uuid = "")
PB.field_numbers(::Type{Uuid}) = (;uuid = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Uuid})
    uuid = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            uuid = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Uuid(uuid)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Uuid)
    initpos = position(e.io)
    !isempty(x.uuid) && PB.encode(e, 1, x.uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Uuid)
    encoded_size = 0
    !isempty(x.uuid) && (encoded_size += PB._encoded_size(x.uuid, 1))
    return encoded_size
end

struct Constraint_Custom
    constraint_type::String
    constraint_value::String
end
PB.default_values(::Type{Constraint_Custom}) = (;constraint_type = "", constraint_value = "")
PB.field_numbers(::Type{Constraint_Custom}) = (;constraint_type = 1, constraint_value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_Custom})
    constraint_type = ""
    constraint_value = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            constraint_type = PB.decode(d, String)
        elseif field_number == 2
            constraint_value = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_Custom(constraint_type, constraint_value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_Custom)
    initpos = position(e.io)
    !isempty(x.constraint_type) && PB.encode(e, 1, x.constraint_type)
    !isempty(x.constraint_value) && PB.encode(e, 2, x.constraint_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_Custom)
    encoded_size = 0
    !isempty(x.constraint_type) && (encoded_size += PB._encoded_size(x.constraint_type, 1))
    !isempty(x.constraint_value) && (encoded_size += PB._encoded_size(x.constraint_value, 2))
    return encoded_size
end

struct GPS_Position
    latitude::Float32
    longitude::Float32
end
PB.default_values(::Type{GPS_Position}) = (;latitude = zero(Float32), longitude = zero(Float32))
PB.field_numbers(::Type{GPS_Position}) = (;latitude = 1, longitude = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GPS_Position})
    latitude = zero(Float32)
    longitude = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            latitude = PB.decode(d, Float32)
        elseif field_number == 2
            longitude = PB.decode(d, Float32)
        else
            PB.skip(d, wire_type)
        end
    end
    return GPS_Position(latitude, longitude)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GPS_Position)
    initpos = position(e.io)
    x.latitude !== zero(Float32) && PB.encode(e, 1, x.latitude)
    x.longitude !== zero(Float32) && PB.encode(e, 2, x.longitude)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GPS_Position)
    encoded_size = 0
    x.latitude !== zero(Float32) && (encoded_size += PB._encoded_size(x.latitude, 1))
    x.longitude !== zero(Float32) && (encoded_size += PB._encoded_size(x.longitude, 2))
    return encoded_size
end

@enumx ServiceStatusEnum SERVICESTATUS_UNDEFINED=0 SERVICESTATUS_PLANNED=1 SERVICESTATUS_ACTIVE=2 SERVICESTATUS_UPDATING=3 SERVICESTATUS_PENDING_REMOVAL=4 SERVICESTATUS_SLA_VIOLATED=5

@enumx SliceStatusEnum SLICESTATUS_UNDEFINED=0 SLICESTATUS_PLANNED=1 SLICESTATUS_INIT=2 SLICESTATUS_ACTIVE=3 SLICESTATUS_DEINIT=4 SLICESTATUS_SLA_VIOLATED=5

struct ConnectionSettings_L3
    src_ip_address::String
    dst_ip_address::String
    dscp::UInt32
    protocol::UInt32
    ttl::UInt32
end
PB.default_values(::Type{ConnectionSettings_L3}) = (;src_ip_address = "", dst_ip_address = "", dscp = zero(UInt32), protocol = zero(UInt32), ttl = zero(UInt32))
PB.field_numbers(::Type{ConnectionSettings_L3}) = (;src_ip_address = 1, dst_ip_address = 2, dscp = 3, protocol = 4, ttl = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionSettings_L3})
    src_ip_address = ""
    dst_ip_address = ""
    dscp = zero(UInt32)
    protocol = zero(UInt32)
    ttl = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            src_ip_address = PB.decode(d, String)
        elseif field_number == 2
            dst_ip_address = PB.decode(d, String)
        elseif field_number == 3
            dscp = PB.decode(d, UInt32)
        elseif field_number == 4
            protocol = PB.decode(d, UInt32)
        elseif field_number == 5
            ttl = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionSettings_L3(src_ip_address, dst_ip_address, dscp, protocol, ttl)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionSettings_L3)
    initpos = position(e.io)
    !isempty(x.src_ip_address) && PB.encode(e, 1, x.src_ip_address)
    !isempty(x.dst_ip_address) && PB.encode(e, 2, x.dst_ip_address)
    x.dscp != zero(UInt32) && PB.encode(e, 3, x.dscp)
    x.protocol != zero(UInt32) && PB.encode(e, 4, x.protocol)
    x.ttl != zero(UInt32) && PB.encode(e, 5, x.ttl)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionSettings_L3)
    encoded_size = 0
    !isempty(x.src_ip_address) && (encoded_size += PB._encoded_size(x.src_ip_address, 1))
    !isempty(x.dst_ip_address) && (encoded_size += PB._encoded_size(x.dst_ip_address, 2))
    x.dscp != zero(UInt32) && (encoded_size += PB._encoded_size(x.dscp, 3))
    x.protocol != zero(UInt32) && (encoded_size += PB._encoded_size(x.protocol, 4))
    x.ttl != zero(UInt32) && (encoded_size += PB._encoded_size(x.ttl, 5))
    return encoded_size
end

struct Constraint_SLA_Capacity
    capacity_gbps::Float32
end
PB.default_values(::Type{Constraint_SLA_Capacity}) = (;capacity_gbps = zero(Float32))
PB.field_numbers(::Type{Constraint_SLA_Capacity}) = (;capacity_gbps = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_SLA_Capacity})
    capacity_gbps = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            capacity_gbps = PB.decode(d, Float32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_SLA_Capacity(capacity_gbps)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_SLA_Capacity)
    initpos = position(e.io)
    x.capacity_gbps !== zero(Float32) && PB.encode(e, 1, x.capacity_gbps)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_SLA_Capacity)
    encoded_size = 0
    x.capacity_gbps !== zero(Float32) && (encoded_size += PB._encoded_size(x.capacity_gbps, 1))
    return encoded_size
end

struct LinkAttributes
    total_capacity_gbps::Float32
    used_capacity_gbps::Float32
end
PB.default_values(::Type{LinkAttributes}) = (;total_capacity_gbps = zero(Float32), used_capacity_gbps = zero(Float32))
PB.field_numbers(::Type{LinkAttributes}) = (;total_capacity_gbps = 1, used_capacity_gbps = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkAttributes})
    total_capacity_gbps = zero(Float32)
    used_capacity_gbps = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            total_capacity_gbps = PB.decode(d, Float32)
        elseif field_number == 2
            used_capacity_gbps = PB.decode(d, Float32)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinkAttributes(total_capacity_gbps, used_capacity_gbps)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkAttributes)
    initpos = position(e.io)
    x.total_capacity_gbps !== zero(Float32) && PB.encode(e, 1, x.total_capacity_gbps)
    x.used_capacity_gbps !== zero(Float32) && PB.encode(e, 2, x.used_capacity_gbps)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkAttributes)
    encoded_size = 0
    x.total_capacity_gbps !== zero(Float32) && (encoded_size += PB._encoded_size(x.total_capacity_gbps, 1))
    x.used_capacity_gbps !== zero(Float32) && (encoded_size += PB._encoded_size(x.used_capacity_gbps, 2))
    return encoded_size
end

struct Constraint_Schedule
    start_timestamp::Float64
    duration_days::Float32
end
PB.default_values(::Type{Constraint_Schedule}) = (;start_timestamp = zero(Float64), duration_days = zero(Float32))
PB.field_numbers(::Type{Constraint_Schedule}) = (;start_timestamp = 1, duration_days = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_Schedule})
    start_timestamp = zero(Float64)
    duration_days = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            start_timestamp = PB.decode(d, Float64)
        elseif field_number == 2
            duration_days = PB.decode(d, Float32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_Schedule(start_timestamp, duration_days)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_Schedule)
    initpos = position(e.io)
    x.start_timestamp !== zero(Float64) && PB.encode(e, 1, x.start_timestamp)
    x.duration_days !== zero(Float32) && PB.encode(e, 2, x.duration_days)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_Schedule)
    encoded_size = 0
    x.start_timestamp !== zero(Float64) && (encoded_size += PB._encoded_size(x.start_timestamp, 1))
    x.duration_days !== zero(Float32) && (encoded_size += PB._encoded_size(x.duration_days, 2))
    return encoded_size
end

@enumx ConfigActionEnum CONFIGACTION_UNDEFINED=0 CONFIGACTION_SET=1 CONFIGACTION_DELETE=2

@enumx IsolationLevelEnum NO_ISOLATION=0 PHYSICAL_ISOLATION=1 LOGICAL_ISOLATION=2 PROCESS_ISOLATION=3 PHYSICAL_MEMORY_ISOLATION=4 PHYSICAL_NETWORK_ISOLATION=5 VIRTUAL_RESOURCE_ISOLATION=6 NETWORK_FUNCTIONS_ISOLATION=7 SERVICE_ISOLATION=8

struct Constraint_SLA_Latency
    e2e_latency_ms::Float32
end
PB.default_values(::Type{Constraint_SLA_Latency}) = (;e2e_latency_ms = zero(Float32))
PB.field_numbers(::Type{Constraint_SLA_Latency}) = (;e2e_latency_ms = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_SLA_Latency})
    e2e_latency_ms = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            e2e_latency_ms = PB.decode(d, Float32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_SLA_Latency(e2e_latency_ms)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_SLA_Latency)
    initpos = position(e.io)
    x.e2e_latency_ms !== zero(Float32) && PB.encode(e, 1, x.e2e_latency_ms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_SLA_Latency)
    encoded_size = 0
    x.e2e_latency_ms !== zero(Float32) && (encoded_size += PB._encoded_size(x.e2e_latency_ms, 1))
    return encoded_size
end

struct ConnectionSettings_L2
    src_mac_address::String
    dst_mac_address::String
    ether_type::UInt32
    vlan_id::UInt32
    mpls_label::UInt32
    mpls_traffic_class::UInt32
end
PB.default_values(::Type{ConnectionSettings_L2}) = (;src_mac_address = "", dst_mac_address = "", ether_type = zero(UInt32), vlan_id = zero(UInt32), mpls_label = zero(UInt32), mpls_traffic_class = zero(UInt32))
PB.field_numbers(::Type{ConnectionSettings_L2}) = (;src_mac_address = 1, dst_mac_address = 2, ether_type = 3, vlan_id = 4, mpls_label = 5, mpls_traffic_class = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionSettings_L2})
    src_mac_address = ""
    dst_mac_address = ""
    ether_type = zero(UInt32)
    vlan_id = zero(UInt32)
    mpls_label = zero(UInt32)
    mpls_traffic_class = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            src_mac_address = PB.decode(d, String)
        elseif field_number == 2
            dst_mac_address = PB.decode(d, String)
        elseif field_number == 3
            ether_type = PB.decode(d, UInt32)
        elseif field_number == 4
            vlan_id = PB.decode(d, UInt32)
        elseif field_number == 5
            mpls_label = PB.decode(d, UInt32)
        elseif field_number == 6
            mpls_traffic_class = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionSettings_L2(src_mac_address, dst_mac_address, ether_type, vlan_id, mpls_label, mpls_traffic_class)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionSettings_L2)
    initpos = position(e.io)
    !isempty(x.src_mac_address) && PB.encode(e, 1, x.src_mac_address)
    !isempty(x.dst_mac_address) && PB.encode(e, 2, x.dst_mac_address)
    x.ether_type != zero(UInt32) && PB.encode(e, 3, x.ether_type)
    x.vlan_id != zero(UInt32) && PB.encode(e, 4, x.vlan_id)
    x.mpls_label != zero(UInt32) && PB.encode(e, 5, x.mpls_label)
    x.mpls_traffic_class != zero(UInt32) && PB.encode(e, 6, x.mpls_traffic_class)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionSettings_L2)
    encoded_size = 0
    !isempty(x.src_mac_address) && (encoded_size += PB._encoded_size(x.src_mac_address, 1))
    !isempty(x.dst_mac_address) && (encoded_size += PB._encoded_size(x.dst_mac_address, 2))
    x.ether_type != zero(UInt32) && (encoded_size += PB._encoded_size(x.ether_type, 3))
    x.vlan_id != zero(UInt32) && (encoded_size += PB._encoded_size(x.vlan_id, 4))
    x.mpls_label != zero(UInt32) && (encoded_size += PB._encoded_size(x.mpls_label, 5))
    x.mpls_traffic_class != zero(UInt32) && (encoded_size += PB._encoded_size(x.mpls_traffic_class, 6))
    return encoded_size
end

struct OpticalConfigId
    opticalconfig_uuid::String
end
PB.default_values(::Type{OpticalConfigId}) = (;opticalconfig_uuid = "")
PB.field_numbers(::Type{OpticalConfigId}) = (;opticalconfig_uuid = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalConfigId})
    opticalconfig_uuid = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            opticalconfig_uuid = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalConfigId(opticalconfig_uuid)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalConfigId)
    initpos = position(e.io)
    !isempty(x.opticalconfig_uuid) && PB.encode(e, 1, x.opticalconfig_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalConfigId)
    encoded_size = 0
    !isempty(x.opticalconfig_uuid) && (encoded_size += PB._encoded_size(x.opticalconfig_uuid, 1))
    return encoded_size
end

@enumx ServiceTypeEnum SERVICETYPE_UNKNOWN=0 SERVICETYPE_L3NM=1 SERVICETYPE_L2NM=2 SERVICETYPE_TAPI_CONNECTIVITY_SERVICE=3 SERVICETYPE_TE=4 SERVICETYPE_E2E=5 SERVICETYPE_OPTICAL_CONNECTIVITY=6 SERVICETYPE_QKD=7

@enumx ConstraintActionEnum CONSTRAINTACTION_UNDEFINED=0 CONSTRAINTACTION_SET=1 CONSTRAINTACTION_DELETE=2

struct Constraint_SLA_Availability
    num_disjoint_paths::UInt32
    all_active::Bool
    availability::Float32
end
PB.default_values(::Type{Constraint_SLA_Availability}) = (;num_disjoint_paths = zero(UInt32), all_active = false, availability = zero(Float32))
PB.field_numbers(::Type{Constraint_SLA_Availability}) = (;num_disjoint_paths = 1, all_active = 2, availability = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_SLA_Availability})
    num_disjoint_paths = zero(UInt32)
    all_active = false
    availability = zero(Float32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            num_disjoint_paths = PB.decode(d, UInt32)
        elseif field_number == 2
            all_active = PB.decode(d, Bool)
        elseif field_number == 3
            availability = PB.decode(d, Float32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_SLA_Availability(num_disjoint_paths, all_active, availability)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_SLA_Availability)
    initpos = position(e.io)
    x.num_disjoint_paths != zero(UInt32) && PB.encode(e, 1, x.num_disjoint_paths)
    x.all_active != false && PB.encode(e, 2, x.all_active)
    x.availability !== zero(Float32) && PB.encode(e, 3, x.availability)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_SLA_Availability)
    encoded_size = 0
    x.num_disjoint_paths != zero(UInt32) && (encoded_size += PB._encoded_size(x.num_disjoint_paths, 1))
    x.all_active != false && (encoded_size += PB._encoded_size(x.all_active, 2))
    x.availability !== zero(Float32) && (encoded_size += PB._encoded_size(x.availability, 3))
    return encoded_size
end

struct Empty end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Empty})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return Empty()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Empty)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Empty)
    encoded_size = 0
    return encoded_size
end

@enumx DeviceDriverEnum DEVICEDRIVER_UNDEFINED=0 DEVICEDRIVER_OPENCONFIG=1 DEVICEDRIVER_TRANSPORT_API=2 DEVICEDRIVER_P4=3 DEVICEDRIVER_IETF_NETWORK_TOPOLOGY=4 DEVICEDRIVER_ONF_TR_532=5 DEVICEDRIVER_XR=6 DEVICEDRIVER_IETF_L2VPN=7 DEVICEDRIVER_GNMI_OPENCONFIG=8 DEVICEDRIVER_OPTICAL_TFS=9 DEVICEDRIVER_IETF_ACTN=10 DEVICEDRIVER_OC=11 DEVICEDRIVER_QKD=12

@enumx EventTypeEnum EVENTTYPE_UNDEFINED=0 EVENTTYPE_CREATE=1 EVENTTYPE_UPDATE=2 EVENTTYPE_REMOVE=3

struct DeviceId
    device_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{DeviceId}) = (;device_uuid = nothing)
PB.field_numbers(::Type{DeviceId}) = (;device_uuid = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceId})
    device_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, device_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceId(device_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceId)
    initpos = position(e.io)
    !isnothing(x.device_uuid) && PB.encode(e, 1, x.device_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceId)
    encoded_size = 0
    !isnothing(x.device_uuid) && (encoded_size += PB._encoded_size(x.device_uuid, 1))
    return encoded_size
end

struct LinkId
    link_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{LinkId}) = (;link_uuid = nothing)
PB.field_numbers(::Type{LinkId}) = (;link_uuid = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkId})
    link_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, link_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinkId(link_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkId)
    initpos = position(e.io)
    !isnothing(x.link_uuid) && PB.encode(e, 1, x.link_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkId)
    encoded_size = 0
    !isnothing(x.link_uuid) && (encoded_size += PB._encoded_size(x.link_uuid, 1))
    return encoded_size
end

struct ContextId
    context_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{ContextId}) = (;context_uuid = nothing)
PB.field_numbers(::Type{ContextId}) = (;context_uuid = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ContextId})
    context_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return ContextId(context_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ContextId)
    initpos = position(e.io)
    !isnothing(x.context_uuid) && PB.encode(e, 1, x.context_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ContextId)
    encoded_size = 0
    !isnothing(x.context_uuid) && (encoded_size += PB._encoded_size(x.context_uuid, 1))
    return encoded_size
end

struct ConnectionId
    connection_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{ConnectionId}) = (;connection_uuid = nothing)
PB.field_numbers(::Type{ConnectionId}) = (;connection_uuid = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionId})
    connection_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, connection_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionId(connection_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionId)
    initpos = position(e.io)
    !isnothing(x.connection_uuid) && PB.encode(e, 1, x.connection_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionId)
    encoded_size = 0
    !isnothing(x.connection_uuid) && (encoded_size += PB._encoded_size(x.connection_uuid, 1))
    return encoded_size
end

struct SliceOwner
    owner_uuid::Union{Nothing,Uuid}
    owner_string::String
end
PB.default_values(::Type{SliceOwner}) = (;owner_uuid = nothing, owner_string = "")
PB.field_numbers(::Type{SliceOwner}) = (;owner_uuid = 1, owner_string = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceOwner})
    owner_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    owner_string = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, owner_uuid)
        elseif field_number == 2
            owner_string = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceOwner(owner_uuid[], owner_string)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceOwner)
    initpos = position(e.io)
    !isnothing(x.owner_uuid) && PB.encode(e, 1, x.owner_uuid)
    !isempty(x.owner_string) && PB.encode(e, 2, x.owner_string)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceOwner)
    encoded_size = 0
    !isnothing(x.owner_uuid) && (encoded_size += PB._encoded_size(x.owner_uuid, 1))
    !isempty(x.owner_string) && (encoded_size += PB._encoded_size(x.owner_string, 2))
    return encoded_size
end

struct QoSProfileId
    qos_profile_id::Union{Nothing,Uuid}
end
PB.default_values(::Type{QoSProfileId}) = (;qos_profile_id = nothing)
PB.field_numbers(::Type{QoSProfileId}) = (;qos_profile_id = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:QoSProfileId})
    qos_profile_id = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, qos_profile_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return QoSProfileId(qos_profile_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::QoSProfileId)
    initpos = position(e.io)
    !isnothing(x.qos_profile_id) && PB.encode(e, 1, x.qos_profile_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::QoSProfileId)
    encoded_size = 0
    !isnothing(x.qos_profile_id) && (encoded_size += PB._encoded_size(x.qos_profile_id, 1))
    return encoded_size
end

struct Component
    component_uuid::Union{Nothing,Uuid}
    name::String
    var"#type"::String
    attributes::Dict{String,String}
    parent::String
end
PB.default_values(::Type{Component}) = (;component_uuid = nothing, name = "", var"#type" = "", attributes = Dict{String,String}(), parent = "")
PB.field_numbers(::Type{Component}) = (;component_uuid = 1, name = 2, var"#type" = 3, attributes = 4, parent = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Component})
    component_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    name = ""
    var"#type" = ""
    attributes = Dict{String,String}()
    parent = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, component_uuid)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            var"#type" = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, attributes)
        elseif field_number == 5
            parent = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Component(component_uuid[], name, var"#type", attributes, parent)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Component)
    initpos = position(e.io)
    !isnothing(x.component_uuid) && PB.encode(e, 1, x.component_uuid)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.var"#type") && PB.encode(e, 3, x.var"#type")
    !isempty(x.attributes) && PB.encode(e, 4, x.attributes)
    !isempty(x.parent) && PB.encode(e, 5, x.parent)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Component)
    encoded_size = 0
    !isnothing(x.component_uuid) && (encoded_size += PB._encoded_size(x.component_uuid, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 3))
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 4))
    !isempty(x.parent) && (encoded_size += PB._encoded_size(x.parent, 5))
    return encoded_size
end

struct Location
    location::Union{Nothing,OneOf{<:Union{String,GPS_Position}}}
end
PB.oneof_field_types(::Type{Location}) = (;
    location = (;region=String, gps_position=GPS_Position, interface=String, circuit_pack=String),
)
PB.default_values(::Type{Location}) = (;region = "", gps_position = nothing, interface = "", circuit_pack = "")
PB.field_numbers(::Type{Location}) = (;region = 1, gps_position = 2, interface = 3, circuit_pack = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Location})
    location = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            location = OneOf(:region, PB.decode(d, String))
        elseif field_number == 2
            location = OneOf(:gps_position, PB.decode(d, Ref{GPS_Position}))
        elseif field_number == 3
            location = OneOf(:interface, PB.decode(d, String))
        elseif field_number == 4
            location = OneOf(:circuit_pack, PB.decode(d, String))
        else
            PB.skip(d, wire_type)
        end
    end
    return Location(location)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Location)
    initpos = position(e.io)
    if isnothing(x.location);
    elseif x.location.name === :region
        PB.encode(e, 1, x.location[]::String)
    elseif x.location.name === :gps_position
        PB.encode(e, 2, x.location[]::GPS_Position)
    elseif x.location.name === :interface
        PB.encode(e, 3, x.location[]::String)
    elseif x.location.name === :circuit_pack
        PB.encode(e, 4, x.location[]::String)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Location)
    encoded_size = 0
    if isnothing(x.location);
    elseif x.location.name === :region
        encoded_size += PB._encoded_size(x.location[]::String, 1)
    elseif x.location.name === :gps_position
        encoded_size += PB._encoded_size(x.location[]::GPS_Position, 2)
    elseif x.location.name === :interface
        encoded_size += PB._encoded_size(x.location[]::String, 3)
    elseif x.location.name === :circuit_pack
        encoded_size += PB._encoded_size(x.location[]::String, 4)
    end
    return encoded_size
end

struct ServiceStatus
    service_status::ServiceStatusEnum.T
end
PB.default_values(::Type{ServiceStatus}) = (;service_status = ServiceStatusEnum.SERVICESTATUS_UNDEFINED)
PB.field_numbers(::Type{ServiceStatus}) = (;service_status = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceStatus})
    service_status = ServiceStatusEnum.SERVICESTATUS_UNDEFINED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            service_status = PB.decode(d, ServiceStatusEnum.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceStatus(service_status)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceStatus)
    initpos = position(e.io)
    x.service_status != ServiceStatusEnum.SERVICESTATUS_UNDEFINED && PB.encode(e, 1, x.service_status)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceStatus)
    encoded_size = 0
    x.service_status != ServiceStatusEnum.SERVICESTATUS_UNDEFINED && (encoded_size += PB._encoded_size(x.service_status, 1))
    return encoded_size
end

struct SliceStatus
    slice_status::SliceStatusEnum.T
end
PB.default_values(::Type{SliceStatus}) = (;slice_status = SliceStatusEnum.SLICESTATUS_UNDEFINED)
PB.field_numbers(::Type{SliceStatus}) = (;slice_status = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceStatus})
    slice_status = SliceStatusEnum.SLICESTATUS_UNDEFINED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            slice_status = PB.decode(d, SliceStatusEnum.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceStatus(slice_status)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceStatus)
    initpos = position(e.io)
    x.slice_status != SliceStatusEnum.SLICESTATUS_UNDEFINED && PB.encode(e, 1, x.slice_status)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceStatus)
    encoded_size = 0
    x.slice_status != SliceStatusEnum.SLICESTATUS_UNDEFINED && (encoded_size += PB._encoded_size(x.slice_status, 1))
    return encoded_size
end

struct Constraint_SLA_Isolation_level
    isolation_level::Vector{IsolationLevelEnum.T}
end
PB.default_values(::Type{Constraint_SLA_Isolation_level}) = (;isolation_level = Vector{IsolationLevelEnum.T}())
PB.field_numbers(::Type{Constraint_SLA_Isolation_level}) = (;isolation_level = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_SLA_Isolation_level})
    isolation_level = PB.BufferedVector{IsolationLevelEnum.T}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, isolation_level)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_SLA_Isolation_level(isolation_level[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_SLA_Isolation_level)
    initpos = position(e.io)
    !isempty(x.isolation_level) && PB.encode(e, 1, x.isolation_level)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_SLA_Isolation_level)
    encoded_size = 0
    !isempty(x.isolation_level) && (encoded_size += PB._encoded_size(x.isolation_level, 1))
    return encoded_size
end

struct ConnectionSettings
    l0::Union{Nothing,ConnectionSettings_L0}
    l2::Union{Nothing,ConnectionSettings_L2}
    l3::Union{Nothing,ConnectionSettings_L3}
    l4::Union{Nothing,ConnectionSettings_L4}
end
PB.default_values(::Type{ConnectionSettings}) = (;l0 = nothing, l2 = nothing, l3 = nothing, l4 = nothing)
PB.field_numbers(::Type{ConnectionSettings}) = (;l0 = 1, l2 = 2, l3 = 3, l4 = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionSettings})
    l0 = Ref{Union{Nothing,ConnectionSettings_L0}}(nothing)
    l2 = Ref{Union{Nothing,ConnectionSettings_L2}}(nothing)
    l3 = Ref{Union{Nothing,ConnectionSettings_L3}}(nothing)
    l4 = Ref{Union{Nothing,ConnectionSettings_L4}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, l0)
        elseif field_number == 2
            PB.decode!(d, l2)
        elseif field_number == 3
            PB.decode!(d, l3)
        elseif field_number == 4
            PB.decode!(d, l4)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionSettings(l0[], l2[], l3[], l4[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionSettings)
    initpos = position(e.io)
    !isnothing(x.l0) && PB.encode(e, 1, x.l0)
    !isnothing(x.l2) && PB.encode(e, 2, x.l2)
    !isnothing(x.l3) && PB.encode(e, 3, x.l3)
    !isnothing(x.l4) && PB.encode(e, 4, x.l4)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionSettings)
    encoded_size = 0
    !isnothing(x.l0) && (encoded_size += PB._encoded_size(x.l0, 1))
    !isnothing(x.l2) && (encoded_size += PB._encoded_size(x.l2, 2))
    !isnothing(x.l3) && (encoded_size += PB._encoded_size(x.l3, 3))
    !isnothing(x.l4) && (encoded_size += PB._encoded_size(x.l4, 4))
    return encoded_size
end

struct Event
    timestamp::Union{Nothing,Timestamp}
    event_type::EventTypeEnum.T
end
PB.default_values(::Type{Event}) = (;timestamp = nothing, event_type = EventTypeEnum.EVENTTYPE_UNDEFINED)
PB.field_numbers(::Type{Event}) = (;timestamp = 1, event_type = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Event})
    timestamp = Ref{Union{Nothing,Timestamp}}(nothing)
    event_type = EventTypeEnum.EVENTTYPE_UNDEFINED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, timestamp)
        elseif field_number == 2
            event_type = PB.decode(d, EventTypeEnum.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return Event(timestamp[], event_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Event)
    initpos = position(e.io)
    !isnothing(x.timestamp) && PB.encode(e, 1, x.timestamp)
    x.event_type != EventTypeEnum.EVENTTYPE_UNDEFINED && PB.encode(e, 2, x.event_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Event)
    encoded_size = 0
    !isnothing(x.timestamp) && (encoded_size += PB._encoded_size(x.timestamp, 1))
    x.event_type != EventTypeEnum.EVENTTYPE_UNDEFINED && (encoded_size += PB._encoded_size(x.event_type, 2))
    return encoded_size
end

struct OpticalConfig
    opticalconfig_id::Union{Nothing,OpticalConfigId}
    config::String
    device_id::Union{Nothing,DeviceId}
end
PB.default_values(::Type{OpticalConfig}) = (;opticalconfig_id = nothing, config = "", device_id = nothing)
PB.field_numbers(::Type{OpticalConfig}) = (;opticalconfig_id = 1, config = 2, device_id = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalConfig})
    opticalconfig_id = Ref{Union{Nothing,OpticalConfigId}}(nothing)
    config = ""
    device_id = Ref{Union{Nothing,DeviceId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, opticalconfig_id)
        elseif field_number == 2
            config = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, device_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalConfig(opticalconfig_id[], config, device_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalConfig)
    initpos = position(e.io)
    !isnothing(x.opticalconfig_id) && PB.encode(e, 1, x.opticalconfig_id)
    !isempty(x.config) && PB.encode(e, 2, x.config)
    !isnothing(x.device_id) && PB.encode(e, 3, x.device_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalConfig)
    encoded_size = 0
    !isnothing(x.opticalconfig_id) && (encoded_size += PB._encoded_size(x.opticalconfig_id, 1))
    !isempty(x.config) && (encoded_size += PB._encoded_size(x.config, 2))
    !isnothing(x.device_id) && (encoded_size += PB._encoded_size(x.device_id, 3))
    return encoded_size
end

struct DeviceIdList
    device_ids::Vector{DeviceId}
end
PB.default_values(::Type{DeviceIdList}) = (;device_ids = Vector{DeviceId}())
PB.field_numbers(::Type{DeviceIdList}) = (;device_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceIdList})
    device_ids = PB.BufferedVector{DeviceId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, device_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceIdList(device_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceIdList)
    initpos = position(e.io)
    !isempty(x.device_ids) && PB.encode(e, 1, x.device_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceIdList)
    encoded_size = 0
    !isempty(x.device_ids) && (encoded_size += PB._encoded_size(x.device_ids, 1))
    return encoded_size
end

struct OpticalEndPointId
    device_id::Union{Nothing,DeviceId}
    endpoint_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{OpticalEndPointId}) = (;device_id = nothing, endpoint_uuid = nothing)
PB.field_numbers(::Type{OpticalEndPointId}) = (;device_id = 2, endpoint_uuid = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalEndPointId})
    device_id = Ref{Union{Nothing,DeviceId}}(nothing)
    endpoint_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            PB.decode!(d, device_id)
        elseif field_number == 3
            PB.decode!(d, endpoint_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalEndPointId(device_id[], endpoint_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalEndPointId)
    initpos = position(e.io)
    !isnothing(x.device_id) && PB.encode(e, 2, x.device_id)
    !isnothing(x.endpoint_uuid) && PB.encode(e, 3, x.endpoint_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalEndPointId)
    encoded_size = 0
    !isnothing(x.device_id) && (encoded_size += PB._encoded_size(x.device_id, 2))
    !isnothing(x.endpoint_uuid) && (encoded_size += PB._encoded_size(x.endpoint_uuid, 3))
    return encoded_size
end

struct LinkIdList
    link_ids::Vector{LinkId}
end
PB.default_values(::Type{LinkIdList}) = (;link_ids = Vector{LinkId}())
PB.field_numbers(::Type{LinkIdList}) = (;link_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkIdList})
    link_ids = PB.BufferedVector{LinkId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, link_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinkIdList(link_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkIdList)
    initpos = position(e.io)
    !isempty(x.link_ids) && PB.encode(e, 1, x.link_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkIdList)
    encoded_size = 0
    !isempty(x.link_ids) && (encoded_size += PB._encoded_size(x.link_ids, 1))
    return encoded_size
end

struct TopologyId
    context_id::Union{Nothing,ContextId}
    topology_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{TopologyId}) = (;context_id = nothing, topology_uuid = nothing)
PB.field_numbers(::Type{TopologyId}) = (;context_id = 1, topology_uuid = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TopologyId})
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    topology_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_id)
        elseif field_number == 2
            PB.decode!(d, topology_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return TopologyId(context_id[], topology_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TopologyId)
    initpos = position(e.io)
    !isnothing(x.context_id) && PB.encode(e, 1, x.context_id)
    !isnothing(x.topology_uuid) && PB.encode(e, 2, x.topology_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TopologyId)
    encoded_size = 0
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 1))
    !isnothing(x.topology_uuid) && (encoded_size += PB._encoded_size(x.topology_uuid, 2))
    return encoded_size
end

struct ServiceId
    context_id::Union{Nothing,ContextId}
    service_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{ServiceId}) = (;context_id = nothing, service_uuid = nothing)
PB.field_numbers(::Type{ServiceId}) = (;context_id = 1, service_uuid = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceId})
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    service_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_id)
        elseif field_number == 2
            PB.decode!(d, service_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceId(context_id[], service_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceId)
    initpos = position(e.io)
    !isnothing(x.context_id) && PB.encode(e, 1, x.context_id)
    !isnothing(x.service_uuid) && PB.encode(e, 2, x.service_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceId)
    encoded_size = 0
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 1))
    !isnothing(x.service_uuid) && (encoded_size += PB._encoded_size(x.service_uuid, 2))
    return encoded_size
end

struct TeraFlowController
    context_id::Union{Nothing,ContextId}
    ip_address::String
    port::UInt32
end
PB.default_values(::Type{TeraFlowController}) = (;context_id = nothing, ip_address = "", port = zero(UInt32))
PB.field_numbers(::Type{TeraFlowController}) = (;context_id = 1, ip_address = 2, port = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TeraFlowController})
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    ip_address = ""
    port = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_id)
        elseif field_number == 2
            ip_address = PB.decode(d, String)
        elseif field_number == 3
            port = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return TeraFlowController(context_id[], ip_address, port)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TeraFlowController)
    initpos = position(e.io)
    !isnothing(x.context_id) && PB.encode(e, 1, x.context_id)
    !isempty(x.ip_address) && PB.encode(e, 2, x.ip_address)
    x.port != zero(UInt32) && PB.encode(e, 3, x.port)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TeraFlowController)
    encoded_size = 0
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 1))
    !isempty(x.ip_address) && (encoded_size += PB._encoded_size(x.ip_address, 2))
    x.port != zero(UInt32) && (encoded_size += PB._encoded_size(x.port, 3))
    return encoded_size
end

struct AuthenticationResult
    context_id::Union{Nothing,ContextId}
    authenticated::Bool
end
PB.default_values(::Type{AuthenticationResult}) = (;context_id = nothing, authenticated = false)
PB.field_numbers(::Type{AuthenticationResult}) = (;context_id = 1, authenticated = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AuthenticationResult})
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    authenticated = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_id)
        elseif field_number == 2
            authenticated = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return AuthenticationResult(context_id[], authenticated)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AuthenticationResult)
    initpos = position(e.io)
    !isnothing(x.context_id) && PB.encode(e, 1, x.context_id)
    x.authenticated != false && PB.encode(e, 2, x.authenticated)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AuthenticationResult)
    encoded_size = 0
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 1))
    x.authenticated != false && (encoded_size += PB._encoded_size(x.authenticated, 2))
    return encoded_size
end

struct ContextIdList
    context_ids::Vector{ContextId}
end
PB.default_values(::Type{ContextIdList}) = (;context_ids = Vector{ContextId}())
PB.field_numbers(::Type{ContextIdList}) = (;context_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ContextIdList})
    context_ids = PB.BufferedVector{ContextId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return ContextIdList(context_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ContextIdList)
    initpos = position(e.io)
    !isempty(x.context_ids) && PB.encode(e, 1, x.context_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ContextIdList)
    encoded_size = 0
    !isempty(x.context_ids) && (encoded_size += PB._encoded_size(x.context_ids, 1))
    return encoded_size
end

struct SliceId
    context_id::Union{Nothing,ContextId}
    slice_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{SliceId}) = (;context_id = nothing, slice_uuid = nothing)
PB.field_numbers(::Type{SliceId}) = (;context_id = 1, slice_uuid = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceId})
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    slice_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_id)
        elseif field_number == 2
            PB.decode!(d, slice_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceId(context_id[], slice_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceId)
    initpos = position(e.io)
    !isnothing(x.context_id) && PB.encode(e, 1, x.context_id)
    !isnothing(x.slice_uuid) && PB.encode(e, 2, x.slice_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceId)
    encoded_size = 0
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 1))
    !isnothing(x.slice_uuid) && (encoded_size += PB._encoded_size(x.slice_uuid, 2))
    return encoded_size
end

struct ConnectionIdList
    connection_ids::Vector{ConnectionId}
end
PB.default_values(::Type{ConnectionIdList}) = (;connection_ids = Vector{ConnectionId}())
PB.field_numbers(::Type{ConnectionIdList}) = (;connection_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionIdList})
    connection_ids = PB.BufferedVector{ConnectionId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, connection_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionIdList(connection_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionIdList)
    initpos = position(e.io)
    !isempty(x.connection_ids) && PB.encode(e, 1, x.connection_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionIdList)
    encoded_size = 0
    !isempty(x.connection_ids) && (encoded_size += PB._encoded_size(x.connection_ids, 1))
    return encoded_size
end

struct Constraint_QoSProfile
    qos_profile_id::Union{Nothing,QoSProfileId}
    qos_profile_name::String
end
PB.default_values(::Type{Constraint_QoSProfile}) = (;qos_profile_id = nothing, qos_profile_name = "")
PB.field_numbers(::Type{Constraint_QoSProfile}) = (;qos_profile_id = 1, qos_profile_name = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_QoSProfile})
    qos_profile_id = Ref{Union{Nothing,QoSProfileId}}(nothing)
    qos_profile_name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, qos_profile_id)
        elseif field_number == 2
            qos_profile_name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_QoSProfile(qos_profile_id[], qos_profile_name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_QoSProfile)
    initpos = position(e.io)
    !isnothing(x.qos_profile_id) && PB.encode(e, 1, x.qos_profile_id)
    !isempty(x.qos_profile_name) && PB.encode(e, 2, x.qos_profile_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_QoSProfile)
    encoded_size = 0
    !isnothing(x.qos_profile_id) && (encoded_size += PB._encoded_size(x.qos_profile_id, 1))
    !isempty(x.qos_profile_name) && (encoded_size += PB._encoded_size(x.qos_profile_name, 2))
    return encoded_size
end

struct ConnectionEvent
    event::Union{Nothing,Event}
    connection_id::Union{Nothing,ConnectionId}
end
PB.default_values(::Type{ConnectionEvent}) = (;event = nothing, connection_id = nothing)
PB.field_numbers(::Type{ConnectionEvent}) = (;event = 1, connection_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    connection_id = Ref{Union{Nothing,ConnectionId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, connection_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionEvent(event[], connection_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.connection_id) && PB.encode(e, 2, x.connection_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.connection_id) && (encoded_size += PB._encoded_size(x.connection_id, 2))
    return encoded_size
end

struct ContextEvent
    event::Union{Nothing,Event}
    context_id::Union{Nothing,ContextId}
end
PB.default_values(::Type{ContextEvent}) = (;event = nothing, context_id = nothing)
PB.field_numbers(::Type{ContextEvent}) = (;event = 1, context_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ContextEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, context_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return ContextEvent(event[], context_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ContextEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.context_id) && PB.encode(e, 2, x.context_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ContextEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 2))
    return encoded_size
end

struct LinkEvent
    event::Union{Nothing,Event}
    link_id::Union{Nothing,LinkId}
end
PB.default_values(::Type{LinkEvent}) = (;event = nothing, link_id = nothing)
PB.field_numbers(::Type{LinkEvent}) = (;event = 1, link_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    link_id = Ref{Union{Nothing,LinkId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, link_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinkEvent(event[], link_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.link_id) && PB.encode(e, 2, x.link_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.link_id) && (encoded_size += PB._encoded_size(x.link_id, 2))
    return encoded_size
end

struct OpticalConfigEvent
    event::Union{Nothing,Event}
    opticalconfig_id::Union{Nothing,OpticalConfigId}
end
PB.default_values(::Type{OpticalConfigEvent}) = (;event = nothing, opticalconfig_id = nothing)
PB.field_numbers(::Type{OpticalConfigEvent}) = (;event = 1, opticalconfig_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalConfigEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    opticalconfig_id = Ref{Union{Nothing,OpticalConfigId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, opticalconfig_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalConfigEvent(event[], opticalconfig_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalConfigEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.opticalconfig_id) && PB.encode(e, 2, x.opticalconfig_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalConfigEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.opticalconfig_id) && (encoded_size += PB._encoded_size(x.opticalconfig_id, 2))
    return encoded_size
end

struct OpticalConfigList
    opticalconfigs::Vector{OpticalConfig}
end
PB.default_values(::Type{OpticalConfigList}) = (;opticalconfigs = Vector{OpticalConfig}())
PB.field_numbers(::Type{OpticalConfigList}) = (;opticalconfigs = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalConfigList})
    opticalconfigs = PB.BufferedVector{OpticalConfig}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, opticalconfigs)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalConfigList(opticalconfigs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalConfigList)
    initpos = position(e.io)
    !isempty(x.opticalconfigs) && PB.encode(e, 1, x.opticalconfigs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalConfigList)
    encoded_size = 0
    !isempty(x.opticalconfigs) && (encoded_size += PB._encoded_size(x.opticalconfigs, 1))
    return encoded_size
end

struct DeviceFilter
    device_ids::Union{Nothing,DeviceIdList}
    include_endpoints::Bool
    include_config_rules::Bool
    include_components::Bool
end
PB.default_values(::Type{DeviceFilter}) = (;device_ids = nothing, include_endpoints = false, include_config_rules = false, include_components = false)
PB.field_numbers(::Type{DeviceFilter}) = (;device_ids = 1, include_endpoints = 2, include_config_rules = 3, include_components = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceFilter})
    device_ids = Ref{Union{Nothing,DeviceIdList}}(nothing)
    include_endpoints = false
    include_config_rules = false
    include_components = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, device_ids)
        elseif field_number == 2
            include_endpoints = PB.decode(d, Bool)
        elseif field_number == 3
            include_config_rules = PB.decode(d, Bool)
        elseif field_number == 4
            include_components = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceFilter(device_ids[], include_endpoints, include_config_rules, include_components)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceFilter)
    initpos = position(e.io)
    !isnothing(x.device_ids) && PB.encode(e, 1, x.device_ids)
    x.include_endpoints != false && PB.encode(e, 2, x.include_endpoints)
    x.include_config_rules != false && PB.encode(e, 3, x.include_config_rules)
    x.include_components != false && PB.encode(e, 4, x.include_components)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceFilter)
    encoded_size = 0
    !isnothing(x.device_ids) && (encoded_size += PB._encoded_size(x.device_ids, 1))
    x.include_endpoints != false && (encoded_size += PB._encoded_size(x.include_endpoints, 2))
    x.include_config_rules != false && (encoded_size += PB._encoded_size(x.include_config_rules, 3))
    x.include_components != false && (encoded_size += PB._encoded_size(x.include_components, 4))
    return encoded_size
end

struct TopologyIdList
    topology_ids::Vector{TopologyId}
end
PB.default_values(::Type{TopologyIdList}) = (;topology_ids = Vector{TopologyId}())
PB.field_numbers(::Type{TopologyIdList}) = (;topology_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TopologyIdList})
    topology_ids = PB.BufferedVector{TopologyId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, topology_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return TopologyIdList(topology_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TopologyIdList)
    initpos = position(e.io)
    !isempty(x.topology_ids) && PB.encode(e, 1, x.topology_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TopologyIdList)
    encoded_size = 0
    !isempty(x.topology_ids) && (encoded_size += PB._encoded_size(x.topology_ids, 1))
    return encoded_size
end

struct TopologyEvent
    event::Union{Nothing,Event}
    topology_id::Union{Nothing,TopologyId}
end
PB.default_values(::Type{TopologyEvent}) = (;event = nothing, topology_id = nothing)
PB.field_numbers(::Type{TopologyEvent}) = (;event = 1, topology_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TopologyEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    topology_id = Ref{Union{Nothing,TopologyId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, topology_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return TopologyEvent(event[], topology_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TopologyEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.topology_id) && PB.encode(e, 2, x.topology_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TopologyEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.topology_id) && (encoded_size += PB._encoded_size(x.topology_id, 2))
    return encoded_size
end

struct EndPointId
    topology_id::Union{Nothing,TopologyId}
    device_id::Union{Nothing,DeviceId}
    endpoint_uuid::Union{Nothing,Uuid}
end
PB.default_values(::Type{EndPointId}) = (;topology_id = nothing, device_id = nothing, endpoint_uuid = nothing)
PB.field_numbers(::Type{EndPointId}) = (;topology_id = 1, device_id = 2, endpoint_uuid = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:EndPointId})
    topology_id = Ref{Union{Nothing,TopologyId}}(nothing)
    device_id = Ref{Union{Nothing,DeviceId}}(nothing)
    endpoint_uuid = Ref{Union{Nothing,Uuid}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, topology_id)
        elseif field_number == 2
            PB.decode!(d, device_id)
        elseif field_number == 3
            PB.decode!(d, endpoint_uuid)
        else
            PB.skip(d, wire_type)
        end
    end
    return EndPointId(topology_id[], device_id[], endpoint_uuid[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::EndPointId)
    initpos = position(e.io)
    !isnothing(x.topology_id) && PB.encode(e, 1, x.topology_id)
    !isnothing(x.device_id) && PB.encode(e, 2, x.device_id)
    !isnothing(x.endpoint_uuid) && PB.encode(e, 3, x.endpoint_uuid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::EndPointId)
    encoded_size = 0
    !isnothing(x.topology_id) && (encoded_size += PB._encoded_size(x.topology_id, 1))
    !isnothing(x.device_id) && (encoded_size += PB._encoded_size(x.device_id, 2))
    !isnothing(x.endpoint_uuid) && (encoded_size += PB._encoded_size(x.endpoint_uuid, 3))
    return encoded_size
end

struct Topology
    topology_id::Union{Nothing,TopologyId}
    name::String
    device_ids::Vector{DeviceId}
    link_ids::Vector{LinkId}
    optical_link_ids::Vector{LinkId}
end
PB.default_values(::Type{Topology}) = (;topology_id = nothing, name = "", device_ids = Vector{DeviceId}(), link_ids = Vector{LinkId}(), optical_link_ids = Vector{LinkId}())
PB.field_numbers(::Type{Topology}) = (;topology_id = 1, name = 2, device_ids = 3, link_ids = 4, optical_link_ids = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Topology})
    topology_id = Ref{Union{Nothing,TopologyId}}(nothing)
    name = ""
    device_ids = PB.BufferedVector{DeviceId}()
    link_ids = PB.BufferedVector{LinkId}()
    optical_link_ids = PB.BufferedVector{LinkId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, topology_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, device_ids)
        elseif field_number == 4
            PB.decode!(d, link_ids)
        elseif field_number == 5
            PB.decode!(d, optical_link_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return Topology(topology_id[], name, device_ids[], link_ids[], optical_link_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Topology)
    initpos = position(e.io)
    !isnothing(x.topology_id) && PB.encode(e, 1, x.topology_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.device_ids) && PB.encode(e, 3, x.device_ids)
    !isempty(x.link_ids) && PB.encode(e, 4, x.link_ids)
    !isempty(x.optical_link_ids) && PB.encode(e, 5, x.optical_link_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Topology)
    encoded_size = 0
    !isnothing(x.topology_id) && (encoded_size += PB._encoded_size(x.topology_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.device_ids) && (encoded_size += PB._encoded_size(x.device_ids, 3))
    !isempty(x.link_ids) && (encoded_size += PB._encoded_size(x.link_ids, 4))
    !isempty(x.optical_link_ids) && (encoded_size += PB._encoded_size(x.optical_link_ids, 5))
    return encoded_size
end

struct ServiceEvent
    event::Union{Nothing,Event}
    service_id::Union{Nothing,ServiceId}
end
PB.default_values(::Type{ServiceEvent}) = (;event = nothing, service_id = nothing)
PB.field_numbers(::Type{ServiceEvent}) = (;event = 1, service_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    service_id = Ref{Union{Nothing,ServiceId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, service_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceEvent(event[], service_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.service_id) && PB.encode(e, 2, x.service_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.service_id) && (encoded_size += PB._encoded_size(x.service_id, 2))
    return encoded_size
end

struct ServiceConfigRule
    service_id::Union{Nothing,ServiceId}
    configrule_custom::Union{Nothing,ConfigRule_Custom}
end
PB.default_values(::Type{ServiceConfigRule}) = (;service_id = nothing, configrule_custom = nothing)
PB.field_numbers(::Type{ServiceConfigRule}) = (;service_id = 1, configrule_custom = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceConfigRule})
    service_id = Ref{Union{Nothing,ServiceId}}(nothing)
    configrule_custom = Ref{Union{Nothing,ConfigRule_Custom}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, service_id)
        elseif field_number == 2
            PB.decode!(d, configrule_custom)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceConfigRule(service_id[], configrule_custom[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceConfigRule)
    initpos = position(e.io)
    !isnothing(x.service_id) && PB.encode(e, 1, x.service_id)
    !isnothing(x.configrule_custom) && PB.encode(e, 2, x.configrule_custom)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceConfigRule)
    encoded_size = 0
    !isnothing(x.service_id) && (encoded_size += PB._encoded_size(x.service_id, 1))
    !isnothing(x.configrule_custom) && (encoded_size += PB._encoded_size(x.configrule_custom, 2))
    return encoded_size
end

struct ServiceIdList
    service_ids::Vector{ServiceId}
end
PB.default_values(::Type{ServiceIdList}) = (;service_ids = Vector{ServiceId}())
PB.field_numbers(::Type{ServiceIdList}) = (;service_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceIdList})
    service_ids = PB.BufferedVector{ServiceId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, service_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceIdList(service_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceIdList)
    initpos = position(e.io)
    !isempty(x.service_ids) && PB.encode(e, 1, x.service_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceIdList)
    encoded_size = 0
    !isempty(x.service_ids) && (encoded_size += PB._encoded_size(x.service_ids, 1))
    return encoded_size
end

struct Context
    context_id::Union{Nothing,ContextId}
    name::String
    topology_ids::Vector{TopologyId}
    service_ids::Vector{ServiceId}
    slice_ids::Vector{SliceId}
    controller::Union{Nothing,TeraFlowController}
end
PB.default_values(::Type{Context}) = (;context_id = nothing, name = "", topology_ids = Vector{TopologyId}(), service_ids = Vector{ServiceId}(), slice_ids = Vector{SliceId}(), controller = nothing)
PB.field_numbers(::Type{Context}) = (;context_id = 1, name = 2, topology_ids = 3, service_ids = 4, slice_ids = 5, controller = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Context})
    context_id = Ref{Union{Nothing,ContextId}}(nothing)
    name = ""
    topology_ids = PB.BufferedVector{TopologyId}()
    service_ids = PB.BufferedVector{ServiceId}()
    slice_ids = PB.BufferedVector{SliceId}()
    controller = Ref{Union{Nothing,TeraFlowController}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, context_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, topology_ids)
        elseif field_number == 4
            PB.decode!(d, service_ids)
        elseif field_number == 5
            PB.decode!(d, slice_ids)
        elseif field_number == 6
            PB.decode!(d, controller)
        else
            PB.skip(d, wire_type)
        end
    end
    return Context(context_id[], name, topology_ids[], service_ids[], slice_ids[], controller[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Context)
    initpos = position(e.io)
    !isnothing(x.context_id) && PB.encode(e, 1, x.context_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.topology_ids) && PB.encode(e, 3, x.topology_ids)
    !isempty(x.service_ids) && PB.encode(e, 4, x.service_ids)
    !isempty(x.slice_ids) && PB.encode(e, 5, x.slice_ids)
    !isnothing(x.controller) && PB.encode(e, 6, x.controller)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Context)
    encoded_size = 0
    !isnothing(x.context_id) && (encoded_size += PB._encoded_size(x.context_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.topology_ids) && (encoded_size += PB._encoded_size(x.topology_ids, 3))
    !isempty(x.service_ids) && (encoded_size += PB._encoded_size(x.service_ids, 4))
    !isempty(x.slice_ids) && (encoded_size += PB._encoded_size(x.slice_ids, 5))
    !isnothing(x.controller) && (encoded_size += PB._encoded_size(x.controller, 6))
    return encoded_size
end

struct SliceIdList
    slice_ids::Vector{SliceId}
end
PB.default_values(::Type{SliceIdList}) = (;slice_ids = Vector{SliceId}())
PB.field_numbers(::Type{SliceIdList}) = (;slice_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceIdList})
    slice_ids = PB.BufferedVector{SliceId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, slice_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceIdList(slice_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceIdList)
    initpos = position(e.io)
    !isempty(x.slice_ids) && PB.encode(e, 1, x.slice_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceIdList)
    encoded_size = 0
    !isempty(x.slice_ids) && (encoded_size += PB._encoded_size(x.slice_ids, 1))
    return encoded_size
end

struct SliceEvent
    event::Union{Nothing,Event}
    slice_id::Union{Nothing,SliceId}
end
PB.default_values(::Type{SliceEvent}) = (;event = nothing, slice_id = nothing)
PB.field_numbers(::Type{SliceEvent}) = (;event = 1, slice_id = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    slice_id = Ref{Union{Nothing,SliceId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, slice_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceEvent(event[], slice_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.slice_id) && PB.encode(e, 2, x.slice_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.slice_id) && (encoded_size += PB._encoded_size(x.slice_id, 2))
    return encoded_size
end

struct EndPointName
    endpoint_id::Union{Nothing,EndPointId}
    device_name::String
    endpoint_name::String
    endpoint_type::String
end
PB.default_values(::Type{EndPointName}) = (;endpoint_id = nothing, device_name = "", endpoint_name = "", endpoint_type = "")
PB.field_numbers(::Type{EndPointName}) = (;endpoint_id = 1, device_name = 2, endpoint_name = 3, endpoint_type = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:EndPointName})
    endpoint_id = Ref{Union{Nothing,EndPointId}}(nothing)
    device_name = ""
    endpoint_name = ""
    endpoint_type = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_id)
        elseif field_number == 2
            device_name = PB.decode(d, String)
        elseif field_number == 3
            endpoint_name = PB.decode(d, String)
        elseif field_number == 4
            endpoint_type = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return EndPointName(endpoint_id[], device_name, endpoint_name, endpoint_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::EndPointName)
    initpos = position(e.io)
    !isnothing(x.endpoint_id) && PB.encode(e, 1, x.endpoint_id)
    !isempty(x.device_name) && PB.encode(e, 2, x.device_name)
    !isempty(x.endpoint_name) && PB.encode(e, 3, x.endpoint_name)
    !isempty(x.endpoint_type) && PB.encode(e, 4, x.endpoint_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::EndPointName)
    encoded_size = 0
    !isnothing(x.endpoint_id) && (encoded_size += PB._encoded_size(x.endpoint_id, 1))
    !isempty(x.device_name) && (encoded_size += PB._encoded_size(x.device_name, 2))
    !isempty(x.endpoint_name) && (encoded_size += PB._encoded_size(x.endpoint_name, 3))
    !isempty(x.endpoint_type) && (encoded_size += PB._encoded_size(x.endpoint_type, 4))
    return encoded_size
end

struct Link
    link_id::Union{Nothing,LinkId}
    name::String
    link_endpoint_ids::Vector{EndPointId}
    attributes::Union{Nothing,LinkAttributes}
    link_type::LinkTypeEnum.T
end
PB.default_values(::Type{Link}) = (;link_id = nothing, name = "", link_endpoint_ids = Vector{EndPointId}(), attributes = nothing, link_type = LinkTypeEnum.LINKTYPE_UNKNOWN)
PB.field_numbers(::Type{Link}) = (;link_id = 1, name = 2, link_endpoint_ids = 3, attributes = 4, link_type = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Link})
    link_id = Ref{Union{Nothing,LinkId}}(nothing)
    name = ""
    link_endpoint_ids = PB.BufferedVector{EndPointId}()
    attributes = Ref{Union{Nothing,LinkAttributes}}(nothing)
    link_type = LinkTypeEnum.LINKTYPE_UNKNOWN
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, link_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, link_endpoint_ids)
        elseif field_number == 4
            PB.decode!(d, attributes)
        elseif field_number == 5
            link_type = PB.decode(d, LinkTypeEnum.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return Link(link_id[], name, link_endpoint_ids[], attributes[], link_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Link)
    initpos = position(e.io)
    !isnothing(x.link_id) && PB.encode(e, 1, x.link_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.link_endpoint_ids) && PB.encode(e, 3, x.link_endpoint_ids)
    !isnothing(x.attributes) && PB.encode(e, 4, x.attributes)
    x.link_type != LinkTypeEnum.LINKTYPE_UNKNOWN && PB.encode(e, 5, x.link_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Link)
    encoded_size = 0
    !isnothing(x.link_id) && (encoded_size += PB._encoded_size(x.link_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.link_endpoint_ids) && (encoded_size += PB._encoded_size(x.link_endpoint_ids, 3))
    !isnothing(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 4))
    x.link_type != LinkTypeEnum.LINKTYPE_UNKNOWN && (encoded_size += PB._encoded_size(x.link_type, 5))
    return encoded_size
end

struct Constraint_Exclusions
    is_permanent::Bool
    device_ids::Vector{DeviceId}
    endpoint_ids::Vector{EndPointId}
    link_ids::Vector{LinkId}
end
PB.default_values(::Type{Constraint_Exclusions}) = (;is_permanent = false, device_ids = Vector{DeviceId}(), endpoint_ids = Vector{EndPointId}(), link_ids = Vector{LinkId}())
PB.field_numbers(::Type{Constraint_Exclusions}) = (;is_permanent = 1, device_ids = 2, endpoint_ids = 3, link_ids = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_Exclusions})
    is_permanent = false
    device_ids = PB.BufferedVector{DeviceId}()
    endpoint_ids = PB.BufferedVector{EndPointId}()
    link_ids = PB.BufferedVector{LinkId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            is_permanent = PB.decode(d, Bool)
        elseif field_number == 2
            PB.decode!(d, device_ids)
        elseif field_number == 3
            PB.decode!(d, endpoint_ids)
        elseif field_number == 4
            PB.decode!(d, link_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_Exclusions(is_permanent, device_ids[], endpoint_ids[], link_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_Exclusions)
    initpos = position(e.io)
    x.is_permanent != false && PB.encode(e, 1, x.is_permanent)
    !isempty(x.device_ids) && PB.encode(e, 2, x.device_ids)
    !isempty(x.endpoint_ids) && PB.encode(e, 3, x.endpoint_ids)
    !isempty(x.link_ids) && PB.encode(e, 4, x.link_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_Exclusions)
    encoded_size = 0
    x.is_permanent != false && (encoded_size += PB._encoded_size(x.is_permanent, 1))
    !isempty(x.device_ids) && (encoded_size += PB._encoded_size(x.device_ids, 2))
    !isempty(x.endpoint_ids) && (encoded_size += PB._encoded_size(x.endpoint_ids, 3))
    !isempty(x.link_ids) && (encoded_size += PB._encoded_size(x.link_ids, 4))
    return encoded_size
end

struct Constraint_EndPointPriority
    endpoint_id::Union{Nothing,EndPointId}
    priority::UInt32
end
PB.default_values(::Type{Constraint_EndPointPriority}) = (;endpoint_id = nothing, priority = zero(UInt32))
PB.field_numbers(::Type{Constraint_EndPointPriority}) = (;endpoint_id = 1, priority = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_EndPointPriority})
    endpoint_id = Ref{Union{Nothing,EndPointId}}(nothing)
    priority = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_id)
        elseif field_number == 2
            priority = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_EndPointPriority(endpoint_id[], priority)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_EndPointPriority)
    initpos = position(e.io)
    !isnothing(x.endpoint_id) && PB.encode(e, 1, x.endpoint_id)
    x.priority != zero(UInt32) && PB.encode(e, 2, x.priority)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_EndPointPriority)
    encoded_size = 0
    !isnothing(x.endpoint_id) && (encoded_size += PB._encoded_size(x.endpoint_id, 1))
    x.priority != zero(UInt32) && (encoded_size += PB._encoded_size(x.priority, 2))
    return encoded_size
end

struct EndPoint
    endpoint_id::Union{Nothing,EndPointId}
    name::String
    endpoint_type::String
    kpi_sample_types::Vector{kpi_sample_types.KpiSampleType.T}
    endpoint_location::Union{Nothing,Location}
end
PB.default_values(::Type{EndPoint}) = (;endpoint_id = nothing, name = "", endpoint_type = "", kpi_sample_types = Vector{kpi_sample_types.KpiSampleType.T}(), endpoint_location = nothing)
PB.field_numbers(::Type{EndPoint}) = (;endpoint_id = 1, name = 2, endpoint_type = 3, kpi_sample_types = 4, endpoint_location = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:EndPoint})
    endpoint_id = Ref{Union{Nothing,EndPointId}}(nothing)
    name = ""
    endpoint_type = ""
    kpi_sample_types = PB.BufferedVector{kpi_sample_types.KpiSampleType.T}()
    endpoint_location = Ref{Union{Nothing,Location}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            endpoint_type = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, wire_type, kpi_sample_types)
        elseif field_number == 5
            PB.decode!(d, endpoint_location)
        else
            PB.skip(d, wire_type)
        end
    end
    return EndPoint(endpoint_id[], name, endpoint_type, kpi_sample_types[], endpoint_location[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::EndPoint)
    initpos = position(e.io)
    !isnothing(x.endpoint_id) && PB.encode(e, 1, x.endpoint_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.endpoint_type) && PB.encode(e, 3, x.endpoint_type)
    !isempty(x.kpi_sample_types) && PB.encode(e, 4, x.kpi_sample_types)
    !isnothing(x.endpoint_location) && PB.encode(e, 5, x.endpoint_location)
    return position(e.io) - initpos
end
function PB._encoded_size(x::EndPoint)
    encoded_size = 0
    !isnothing(x.endpoint_id) && (encoded_size += PB._encoded_size(x.endpoint_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.endpoint_type) && (encoded_size += PB._encoded_size(x.endpoint_type, 3))
    !isempty(x.kpi_sample_types) && (encoded_size += PB._encoded_size(x.kpi_sample_types, 4))
    !isnothing(x.endpoint_location) && (encoded_size += PB._encoded_size(x.endpoint_location, 5))
    return encoded_size
end

struct Constraint_EndPointLocation
    endpoint_id::Union{Nothing,EndPointId}
    location::Union{Nothing,Location}
end
PB.default_values(::Type{Constraint_EndPointLocation}) = (;endpoint_id = nothing, location = nothing)
PB.field_numbers(::Type{Constraint_EndPointLocation}) = (;endpoint_id = 1, location = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint_EndPointLocation})
    endpoint_id = Ref{Union{Nothing,EndPointId}}(nothing)
    location = Ref{Union{Nothing,Location}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_id)
        elseif field_number == 2
            PB.decode!(d, location)
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint_EndPointLocation(endpoint_id[], location[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint_EndPointLocation)
    initpos = position(e.io)
    !isnothing(x.endpoint_id) && PB.encode(e, 1, x.endpoint_id)
    !isnothing(x.location) && PB.encode(e, 2, x.location)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint_EndPointLocation)
    encoded_size = 0
    !isnothing(x.endpoint_id) && (encoded_size += PB._encoded_size(x.endpoint_id, 1))
    !isnothing(x.location) && (encoded_size += PB._encoded_size(x.location, 2))
    return encoded_size
end

struct OpticalLink
    name::String
    optical_details::Union{Nothing,OpticalLinkDetails}
    link_id::Union{Nothing,LinkId}
    link_endpoint_ids::Vector{EndPointId}
end
PB.default_values(::Type{OpticalLink}) = (;name = "", optical_details = nothing, link_id = nothing, link_endpoint_ids = Vector{EndPointId}())
PB.field_numbers(::Type{OpticalLink}) = (;name = 1, optical_details = 2, link_id = 3, link_endpoint_ids = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalLink})
    name = ""
    optical_details = Ref{Union{Nothing,OpticalLinkDetails}}(nothing)
    link_id = Ref{Union{Nothing,LinkId}}(nothing)
    link_endpoint_ids = PB.BufferedVector{EndPointId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, optical_details)
        elseif field_number == 3
            PB.decode!(d, link_id)
        elseif field_number == 4
            PB.decode!(d, link_endpoint_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalLink(name, optical_details[], link_id[], link_endpoint_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalLink)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.optical_details) && PB.encode(e, 2, x.optical_details)
    !isnothing(x.link_id) && PB.encode(e, 3, x.link_id)
    !isempty(x.link_endpoint_ids) && PB.encode(e, 4, x.link_endpoint_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalLink)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.optical_details) && (encoded_size += PB._encoded_size(x.optical_details, 2))
    !isnothing(x.link_id) && (encoded_size += PB._encoded_size(x.link_id, 3))
    !isempty(x.link_endpoint_ids) && (encoded_size += PB._encoded_size(x.link_endpoint_ids, 4))
    return encoded_size
end

struct EndPointIdList
    endpoint_ids::Vector{EndPointId}
end
PB.default_values(::Type{EndPointIdList}) = (;endpoint_ids = Vector{EndPointId}())
PB.field_numbers(::Type{EndPointIdList}) = (;endpoint_ids = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:EndPointIdList})
    endpoint_ids = PB.BufferedVector{EndPointId}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return EndPointIdList(endpoint_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::EndPointIdList)
    initpos = position(e.io)
    !isempty(x.endpoint_ids) && PB.encode(e, 1, x.endpoint_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::EndPointIdList)
    encoded_size = 0
    !isempty(x.endpoint_ids) && (encoded_size += PB._encoded_size(x.endpoint_ids, 1))
    return encoded_size
end

struct ConfigRule_ACL
    endpoint_id::Union{Nothing,EndPointId}
    rule_set::Union{Nothing,acl.AclRuleSet}
end
PB.default_values(::Type{ConfigRule_ACL}) = (;endpoint_id = nothing, rule_set = nothing)
PB.field_numbers(::Type{ConfigRule_ACL}) = (;endpoint_id = 1, rule_set = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConfigRule_ACL})
    endpoint_id = Ref{Union{Nothing,EndPointId}}(nothing)
    rule_set = Ref{Union{Nothing,acl.AclRuleSet}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_id)
        elseif field_number == 2
            PB.decode!(d, rule_set)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConfigRule_ACL(endpoint_id[], rule_set[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConfigRule_ACL)
    initpos = position(e.io)
    !isnothing(x.endpoint_id) && PB.encode(e, 1, x.endpoint_id)
    !isnothing(x.rule_set) && PB.encode(e, 2, x.rule_set)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConfigRule_ACL)
    encoded_size = 0
    !isnothing(x.endpoint_id) && (encoded_size += PB._encoded_size(x.endpoint_id, 1))
    !isnothing(x.rule_set) && (encoded_size += PB._encoded_size(x.rule_set, 2))
    return encoded_size
end

struct Connection
    connection_id::Union{Nothing,ConnectionId}
    service_id::Union{Nothing,ServiceId}
    path_hops_endpoint_ids::Vector{EndPointId}
    sub_service_ids::Vector{ServiceId}
    settings::Union{Nothing,ConnectionSettings}
end
PB.default_values(::Type{Connection}) = (;connection_id = nothing, service_id = nothing, path_hops_endpoint_ids = Vector{EndPointId}(), sub_service_ids = Vector{ServiceId}(), settings = nothing)
PB.field_numbers(::Type{Connection}) = (;connection_id = 1, service_id = 2, path_hops_endpoint_ids = 3, sub_service_ids = 4, settings = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Connection})
    connection_id = Ref{Union{Nothing,ConnectionId}}(nothing)
    service_id = Ref{Union{Nothing,ServiceId}}(nothing)
    path_hops_endpoint_ids = PB.BufferedVector{EndPointId}()
    sub_service_ids = PB.BufferedVector{ServiceId}()
    settings = Ref{Union{Nothing,ConnectionSettings}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, connection_id)
        elseif field_number == 2
            PB.decode!(d, service_id)
        elseif field_number == 3
            PB.decode!(d, path_hops_endpoint_ids)
        elseif field_number == 4
            PB.decode!(d, sub_service_ids)
        elseif field_number == 5
            PB.decode!(d, settings)
        else
            PB.skip(d, wire_type)
        end
    end
    return Connection(connection_id[], service_id[], path_hops_endpoint_ids[], sub_service_ids[], settings[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Connection)
    initpos = position(e.io)
    !isnothing(x.connection_id) && PB.encode(e, 1, x.connection_id)
    !isnothing(x.service_id) && PB.encode(e, 2, x.service_id)
    !isempty(x.path_hops_endpoint_ids) && PB.encode(e, 3, x.path_hops_endpoint_ids)
    !isempty(x.sub_service_ids) && PB.encode(e, 4, x.sub_service_ids)
    !isnothing(x.settings) && PB.encode(e, 5, x.settings)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Connection)
    encoded_size = 0
    !isnothing(x.connection_id) && (encoded_size += PB._encoded_size(x.connection_id, 1))
    !isnothing(x.service_id) && (encoded_size += PB._encoded_size(x.service_id, 2))
    !isempty(x.path_hops_endpoint_ids) && (encoded_size += PB._encoded_size(x.path_hops_endpoint_ids, 3))
    !isempty(x.sub_service_ids) && (encoded_size += PB._encoded_size(x.sub_service_ids, 4))
    !isnothing(x.settings) && (encoded_size += PB._encoded_size(x.settings, 5))
    return encoded_size
end

struct TopologyList
    topologies::Vector{Topology}
end
PB.default_values(::Type{TopologyList}) = (;topologies = Vector{Topology}())
PB.field_numbers(::Type{TopologyList}) = (;topologies = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TopologyList})
    topologies = PB.BufferedVector{Topology}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, topologies)
        else
            PB.skip(d, wire_type)
        end
    end
    return TopologyList(topologies[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TopologyList)
    initpos = position(e.io)
    !isempty(x.topologies) && PB.encode(e, 1, x.topologies)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TopologyList)
    encoded_size = 0
    !isempty(x.topologies) && (encoded_size += PB._encoded_size(x.topologies, 1))
    return encoded_size
end

struct ServiceFilter
    service_ids::Union{Nothing,ServiceIdList}
    include_endpoint_ids::Bool
    include_constraints::Bool
    include_config_rules::Bool
end
PB.default_values(::Type{ServiceFilter}) = (;service_ids = nothing, include_endpoint_ids = false, include_constraints = false, include_config_rules = false)
PB.field_numbers(::Type{ServiceFilter}) = (;service_ids = 1, include_endpoint_ids = 2, include_constraints = 3, include_config_rules = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceFilter})
    service_ids = Ref{Union{Nothing,ServiceIdList}}(nothing)
    include_endpoint_ids = false
    include_constraints = false
    include_config_rules = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, service_ids)
        elseif field_number == 2
            include_endpoint_ids = PB.decode(d, Bool)
        elseif field_number == 3
            include_constraints = PB.decode(d, Bool)
        elseif field_number == 4
            include_config_rules = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceFilter(service_ids[], include_endpoint_ids, include_constraints, include_config_rules)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceFilter)
    initpos = position(e.io)
    !isnothing(x.service_ids) && PB.encode(e, 1, x.service_ids)
    x.include_endpoint_ids != false && PB.encode(e, 2, x.include_endpoint_ids)
    x.include_constraints != false && PB.encode(e, 3, x.include_constraints)
    x.include_config_rules != false && PB.encode(e, 4, x.include_config_rules)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceFilter)
    encoded_size = 0
    !isnothing(x.service_ids) && (encoded_size += PB._encoded_size(x.service_ids, 1))
    x.include_endpoint_ids != false && (encoded_size += PB._encoded_size(x.include_endpoint_ids, 2))
    x.include_constraints != false && (encoded_size += PB._encoded_size(x.include_constraints, 3))
    x.include_config_rules != false && (encoded_size += PB._encoded_size(x.include_config_rules, 4))
    return encoded_size
end

struct ContextList
    contexts::Vector{Context}
end
PB.default_values(::Type{ContextList}) = (;contexts = Vector{Context}())
PB.field_numbers(::Type{ContextList}) = (;contexts = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ContextList})
    contexts = PB.BufferedVector{Context}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, contexts)
        else
            PB.skip(d, wire_type)
        end
    end
    return ContextList(contexts[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ContextList)
    initpos = position(e.io)
    !isempty(x.contexts) && PB.encode(e, 1, x.contexts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ContextList)
    encoded_size = 0
    !isempty(x.contexts) && (encoded_size += PB._encoded_size(x.contexts, 1))
    return encoded_size
end

struct SliceFilter
    slice_ids::Union{Nothing,SliceIdList}
    include_endpoint_ids::Bool
    include_constraints::Bool
    include_service_ids::Bool
    include_subslice_ids::Bool
    include_config_rules::Bool
end
PB.default_values(::Type{SliceFilter}) = (;slice_ids = nothing, include_endpoint_ids = false, include_constraints = false, include_service_ids = false, include_subslice_ids = false, include_config_rules = false)
PB.field_numbers(::Type{SliceFilter}) = (;slice_ids = 1, include_endpoint_ids = 2, include_constraints = 3, include_service_ids = 4, include_subslice_ids = 5, include_config_rules = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceFilter})
    slice_ids = Ref{Union{Nothing,SliceIdList}}(nothing)
    include_endpoint_ids = false
    include_constraints = false
    include_service_ids = false
    include_subslice_ids = false
    include_config_rules = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, slice_ids)
        elseif field_number == 2
            include_endpoint_ids = PB.decode(d, Bool)
        elseif field_number == 3
            include_constraints = PB.decode(d, Bool)
        elseif field_number == 4
            include_service_ids = PB.decode(d, Bool)
        elseif field_number == 5
            include_subslice_ids = PB.decode(d, Bool)
        elseif field_number == 6
            include_config_rules = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceFilter(slice_ids[], include_endpoint_ids, include_constraints, include_service_ids, include_subslice_ids, include_config_rules)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceFilter)
    initpos = position(e.io)
    !isnothing(x.slice_ids) && PB.encode(e, 1, x.slice_ids)
    x.include_endpoint_ids != false && PB.encode(e, 2, x.include_endpoint_ids)
    x.include_constraints != false && PB.encode(e, 3, x.include_constraints)
    x.include_service_ids != false && PB.encode(e, 4, x.include_service_ids)
    x.include_subslice_ids != false && PB.encode(e, 5, x.include_subslice_ids)
    x.include_config_rules != false && PB.encode(e, 6, x.include_config_rules)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceFilter)
    encoded_size = 0
    !isnothing(x.slice_ids) && (encoded_size += PB._encoded_size(x.slice_ids, 1))
    x.include_endpoint_ids != false && (encoded_size += PB._encoded_size(x.include_endpoint_ids, 2))
    x.include_constraints != false && (encoded_size += PB._encoded_size(x.include_constraints, 3))
    x.include_service_ids != false && (encoded_size += PB._encoded_size(x.include_service_ids, 4))
    x.include_subslice_ids != false && (encoded_size += PB._encoded_size(x.include_subslice_ids, 5))
    x.include_config_rules != false && (encoded_size += PB._encoded_size(x.include_config_rules, 6))
    return encoded_size
end

struct EndPointNameList
    endpoint_names::Vector{EndPointName}
end
PB.default_values(::Type{EndPointNameList}) = (;endpoint_names = Vector{EndPointName}())
PB.field_numbers(::Type{EndPointNameList}) = (;endpoint_names = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:EndPointNameList})
    endpoint_names = PB.BufferedVector{EndPointName}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, endpoint_names)
        else
            PB.skip(d, wire_type)
        end
    end
    return EndPointNameList(endpoint_names[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::EndPointNameList)
    initpos = position(e.io)
    !isempty(x.endpoint_names) && PB.encode(e, 1, x.endpoint_names)
    return position(e.io) - initpos
end
function PB._encoded_size(x::EndPointNameList)
    encoded_size = 0
    !isempty(x.endpoint_names) && (encoded_size += PB._encoded_size(x.endpoint_names, 1))
    return encoded_size
end

struct LinkList
    links::Vector{Link}
end
PB.default_values(::Type{LinkList}) = (;links = Vector{Link}())
PB.field_numbers(::Type{LinkList}) = (;links = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkList})
    links = PB.BufferedVector{Link}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, links)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinkList(links[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkList)
    initpos = position(e.io)
    !isempty(x.links) && PB.encode(e, 1, x.links)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkList)
    encoded_size = 0
    !isempty(x.links) && (encoded_size += PB._encoded_size(x.links, 1))
    return encoded_size
end

struct Constraint
    action::ConstraintActionEnum.T
    constraint::Union{Nothing,OneOf{<:Union{Constraint_Custom,Constraint_Schedule,Constraint_EndPointLocation,Constraint_EndPointPriority,Constraint_SLA_Capacity,Constraint_SLA_Latency,Constraint_SLA_Availability,Constraint_SLA_Isolation_level,Constraint_Exclusions,Constraint_QoSProfile}}}
end
PB.oneof_field_types(::Type{Constraint}) = (;
    constraint = (;custom=Constraint_Custom, schedule=Constraint_Schedule, endpoint_location=Constraint_EndPointLocation, endpoint_priority=Constraint_EndPointPriority, sla_capacity=Constraint_SLA_Capacity, sla_latency=Constraint_SLA_Latency, sla_availability=Constraint_SLA_Availability, sla_isolation=Constraint_SLA_Isolation_level, exclusions=Constraint_Exclusions, qos_profile=Constraint_QoSProfile),
)
PB.default_values(::Type{Constraint}) = (;action = ConstraintActionEnum.CONSTRAINTACTION_UNDEFINED, custom = nothing, schedule = nothing, endpoint_location = nothing, endpoint_priority = nothing, sla_capacity = nothing, sla_latency = nothing, sla_availability = nothing, sla_isolation = nothing, exclusions = nothing, qos_profile = nothing)
PB.field_numbers(::Type{Constraint}) = (;action = 1, custom = 2, schedule = 3, endpoint_location = 4, endpoint_priority = 5, sla_capacity = 6, sla_latency = 7, sla_availability = 8, sla_isolation = 9, exclusions = 10, qos_profile = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Constraint})
    action = ConstraintActionEnum.CONSTRAINTACTION_UNDEFINED
    constraint = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            action = PB.decode(d, ConstraintActionEnum.T)
        elseif field_number == 2
            constraint = OneOf(:custom, PB.decode(d, Ref{Constraint_Custom}))
        elseif field_number == 3
            constraint = OneOf(:schedule, PB.decode(d, Ref{Constraint_Schedule}))
        elseif field_number == 4
            constraint = OneOf(:endpoint_location, PB.decode(d, Ref{Constraint_EndPointLocation}))
        elseif field_number == 5
            constraint = OneOf(:endpoint_priority, PB.decode(d, Ref{Constraint_EndPointPriority}))
        elseif field_number == 6
            constraint = OneOf(:sla_capacity, PB.decode(d, Ref{Constraint_SLA_Capacity}))
        elseif field_number == 7
            constraint = OneOf(:sla_latency, PB.decode(d, Ref{Constraint_SLA_Latency}))
        elseif field_number == 8
            constraint = OneOf(:sla_availability, PB.decode(d, Ref{Constraint_SLA_Availability}))
        elseif field_number == 9
            constraint = OneOf(:sla_isolation, PB.decode(d, Ref{Constraint_SLA_Isolation_level}))
        elseif field_number == 10
            constraint = OneOf(:exclusions, PB.decode(d, Ref{Constraint_Exclusions}))
        elseif field_number == 11
            constraint = OneOf(:qos_profile, PB.decode(d, Ref{Constraint_QoSProfile}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Constraint(action, constraint)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Constraint)
    initpos = position(e.io)
    x.action != ConstraintActionEnum.CONSTRAINTACTION_UNDEFINED && PB.encode(e, 1, x.action)
    if isnothing(x.constraint);
    elseif x.constraint.name === :custom
        PB.encode(e, 2, x.constraint[]::Constraint_Custom)
    elseif x.constraint.name === :schedule
        PB.encode(e, 3, x.constraint[]::Constraint_Schedule)
    elseif x.constraint.name === :endpoint_location
        PB.encode(e, 4, x.constraint[]::Constraint_EndPointLocation)
    elseif x.constraint.name === :endpoint_priority
        PB.encode(e, 5, x.constraint[]::Constraint_EndPointPriority)
    elseif x.constraint.name === :sla_capacity
        PB.encode(e, 6, x.constraint[]::Constraint_SLA_Capacity)
    elseif x.constraint.name === :sla_latency
        PB.encode(e, 7, x.constraint[]::Constraint_SLA_Latency)
    elseif x.constraint.name === :sla_availability
        PB.encode(e, 8, x.constraint[]::Constraint_SLA_Availability)
    elseif x.constraint.name === :sla_isolation
        PB.encode(e, 9, x.constraint[]::Constraint_SLA_Isolation_level)
    elseif x.constraint.name === :exclusions
        PB.encode(e, 10, x.constraint[]::Constraint_Exclusions)
    elseif x.constraint.name === :qos_profile
        PB.encode(e, 11, x.constraint[]::Constraint_QoSProfile)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Constraint)
    encoded_size = 0
    x.action != ConstraintActionEnum.CONSTRAINTACTION_UNDEFINED && (encoded_size += PB._encoded_size(x.action, 1))
    if isnothing(x.constraint);
    elseif x.constraint.name === :custom
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_Custom, 2)
    elseif x.constraint.name === :schedule
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_Schedule, 3)
    elseif x.constraint.name === :endpoint_location
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_EndPointLocation, 4)
    elseif x.constraint.name === :endpoint_priority
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_EndPointPriority, 5)
    elseif x.constraint.name === :sla_capacity
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_SLA_Capacity, 6)
    elseif x.constraint.name === :sla_latency
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_SLA_Latency, 7)
    elseif x.constraint.name === :sla_availability
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_SLA_Availability, 8)
    elseif x.constraint.name === :sla_isolation
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_SLA_Isolation_level, 9)
    elseif x.constraint.name === :exclusions
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_Exclusions, 10)
    elseif x.constraint.name === :qos_profile
        encoded_size += PB._encoded_size(x.constraint[]::Constraint_QoSProfile, 11)
    end
    return encoded_size
end

struct OpticalLinkList
    optical_links::Vector{OpticalLink}
end
PB.default_values(::Type{OpticalLinkList}) = (;optical_links = Vector{OpticalLink}())
PB.field_numbers(::Type{OpticalLinkList}) = (;optical_links = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OpticalLinkList})
    optical_links = PB.BufferedVector{OpticalLink}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, optical_links)
        else
            PB.skip(d, wire_type)
        end
    end
    return OpticalLinkList(optical_links[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OpticalLinkList)
    initpos = position(e.io)
    !isempty(x.optical_links) && PB.encode(e, 1, x.optical_links)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OpticalLinkList)
    encoded_size = 0
    !isempty(x.optical_links) && (encoded_size += PB._encoded_size(x.optical_links, 1))
    return encoded_size
end

struct ConfigRule
    action::ConfigActionEnum.T
    config_rule::Union{Nothing,OneOf{<:Union{ConfigRule_Custom,ConfigRule_ACL}}}
end
PB.oneof_field_types(::Type{ConfigRule}) = (;
    config_rule = (;custom=ConfigRule_Custom, acl=ConfigRule_ACL),
)
PB.default_values(::Type{ConfigRule}) = (;action = ConfigActionEnum.CONFIGACTION_UNDEFINED, custom = nothing, acl = nothing)
PB.field_numbers(::Type{ConfigRule}) = (;action = 1, custom = 2, acl = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConfigRule})
    action = ConfigActionEnum.CONFIGACTION_UNDEFINED
    config_rule = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            action = PB.decode(d, ConfigActionEnum.T)
        elseif field_number == 2
            config_rule = OneOf(:custom, PB.decode(d, Ref{ConfigRule_Custom}))
        elseif field_number == 3
            config_rule = OneOf(:acl, PB.decode(d, Ref{ConfigRule_ACL}))
        else
            PB.skip(d, wire_type)
        end
    end
    return ConfigRule(action, config_rule)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConfigRule)
    initpos = position(e.io)
    x.action != ConfigActionEnum.CONFIGACTION_UNDEFINED && PB.encode(e, 1, x.action)
    if isnothing(x.config_rule);
    elseif x.config_rule.name === :custom
        PB.encode(e, 2, x.config_rule[]::ConfigRule_Custom)
    elseif x.config_rule.name === :acl
        PB.encode(e, 3, x.config_rule[]::ConfigRule_ACL)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConfigRule)
    encoded_size = 0
    x.action != ConfigActionEnum.CONFIGACTION_UNDEFINED && (encoded_size += PB._encoded_size(x.action, 1))
    if isnothing(x.config_rule);
    elseif x.config_rule.name === :custom
        encoded_size += PB._encoded_size(x.config_rule[]::ConfigRule_Custom, 2)
    elseif x.config_rule.name === :acl
        encoded_size += PB._encoded_size(x.config_rule[]::ConfigRule_ACL, 3)
    end
    return encoded_size
end

struct ConnectionList
    connections::Vector{Connection}
end
PB.default_values(::Type{ConnectionList}) = (;connections = Vector{Connection}())
PB.field_numbers(::Type{ConnectionList}) = (;connections = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConnectionList})
    connections = PB.BufferedVector{Connection}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, connections)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConnectionList(connections[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConnectionList)
    initpos = position(e.io)
    !isempty(x.connections) && PB.encode(e, 1, x.connections)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConnectionList)
    encoded_size = 0
    !isempty(x.connections) && (encoded_size += PB._encoded_size(x.connections, 1))
    return encoded_size
end

struct SliceConfig
    config_rules::Vector{ConfigRule}
end
PB.default_values(::Type{SliceConfig}) = (;config_rules = Vector{ConfigRule}())
PB.field_numbers(::Type{SliceConfig}) = (;config_rules = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceConfig})
    config_rules = PB.BufferedVector{ConfigRule}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, config_rules)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceConfig(config_rules[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceConfig)
    initpos = position(e.io)
    !isempty(x.config_rules) && PB.encode(e, 1, x.config_rules)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceConfig)
    encoded_size = 0
    !isempty(x.config_rules) && (encoded_size += PB._encoded_size(x.config_rules, 1))
    return encoded_size
end

struct DeviceConfig
    config_rules::Vector{ConfigRule}
end
PB.default_values(::Type{DeviceConfig}) = (;config_rules = Vector{ConfigRule}())
PB.field_numbers(::Type{DeviceConfig}) = (;config_rules = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceConfig})
    config_rules = PB.BufferedVector{ConfigRule}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, config_rules)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceConfig(config_rules[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceConfig)
    initpos = position(e.io)
    !isempty(x.config_rules) && PB.encode(e, 1, x.config_rules)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceConfig)
    encoded_size = 0
    !isempty(x.config_rules) && (encoded_size += PB._encoded_size(x.config_rules, 1))
    return encoded_size
end

struct ServiceConfig
    config_rules::Vector{ConfigRule}
end
PB.default_values(::Type{ServiceConfig}) = (;config_rules = Vector{ConfigRule}())
PB.field_numbers(::Type{ServiceConfig}) = (;config_rules = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceConfig})
    config_rules = PB.BufferedVector{ConfigRule}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, config_rules)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceConfig(config_rules[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceConfig)
    initpos = position(e.io)
    !isempty(x.config_rules) && PB.encode(e, 1, x.config_rules)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceConfig)
    encoded_size = 0
    !isempty(x.config_rules) && (encoded_size += PB._encoded_size(x.config_rules, 1))
    return encoded_size
end

struct Slice
    slice_id::Union{Nothing,SliceId}
    name::String
    slice_endpoint_ids::Vector{EndPointId}
    slice_constraints::Vector{Constraint}
    slice_service_ids::Vector{ServiceId}
    slice_subslice_ids::Vector{SliceId}
    slice_status::Union{Nothing,SliceStatus}
    slice_config::Union{Nothing,SliceConfig}
    slice_owner::Union{Nothing,SliceOwner}
    timestamp::Union{Nothing,Timestamp}
end
PB.default_values(::Type{Slice}) = (;slice_id = nothing, name = "", slice_endpoint_ids = Vector{EndPointId}(), slice_constraints = Vector{Constraint}(), slice_service_ids = Vector{ServiceId}(), slice_subslice_ids = Vector{SliceId}(), slice_status = nothing, slice_config = nothing, slice_owner = nothing, timestamp = nothing)
PB.field_numbers(::Type{Slice}) = (;slice_id = 1, name = 2, slice_endpoint_ids = 3, slice_constraints = 4, slice_service_ids = 5, slice_subslice_ids = 6, slice_status = 7, slice_config = 8, slice_owner = 9, timestamp = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Slice})
    slice_id = Ref{Union{Nothing,SliceId}}(nothing)
    name = ""
    slice_endpoint_ids = PB.BufferedVector{EndPointId}()
    slice_constraints = PB.BufferedVector{Constraint}()
    slice_service_ids = PB.BufferedVector{ServiceId}()
    slice_subslice_ids = PB.BufferedVector{SliceId}()
    slice_status = Ref{Union{Nothing,SliceStatus}}(nothing)
    slice_config = Ref{Union{Nothing,SliceConfig}}(nothing)
    slice_owner = Ref{Union{Nothing,SliceOwner}}(nothing)
    timestamp = Ref{Union{Nothing,Timestamp}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, slice_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, slice_endpoint_ids)
        elseif field_number == 4
            PB.decode!(d, slice_constraints)
        elseif field_number == 5
            PB.decode!(d, slice_service_ids)
        elseif field_number == 6
            PB.decode!(d, slice_subslice_ids)
        elseif field_number == 7
            PB.decode!(d, slice_status)
        elseif field_number == 8
            PB.decode!(d, slice_config)
        elseif field_number == 9
            PB.decode!(d, slice_owner)
        elseif field_number == 10
            PB.decode!(d, timestamp)
        else
            PB.skip(d, wire_type)
        end
    end
    return Slice(slice_id[], name, slice_endpoint_ids[], slice_constraints[], slice_service_ids[], slice_subslice_ids[], slice_status[], slice_config[], slice_owner[], timestamp[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Slice)
    initpos = position(e.io)
    !isnothing(x.slice_id) && PB.encode(e, 1, x.slice_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.slice_endpoint_ids) && PB.encode(e, 3, x.slice_endpoint_ids)
    !isempty(x.slice_constraints) && PB.encode(e, 4, x.slice_constraints)
    !isempty(x.slice_service_ids) && PB.encode(e, 5, x.slice_service_ids)
    !isempty(x.slice_subslice_ids) && PB.encode(e, 6, x.slice_subslice_ids)
    !isnothing(x.slice_status) && PB.encode(e, 7, x.slice_status)
    !isnothing(x.slice_config) && PB.encode(e, 8, x.slice_config)
    !isnothing(x.slice_owner) && PB.encode(e, 9, x.slice_owner)
    !isnothing(x.timestamp) && PB.encode(e, 10, x.timestamp)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Slice)
    encoded_size = 0
    !isnothing(x.slice_id) && (encoded_size += PB._encoded_size(x.slice_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.slice_endpoint_ids) && (encoded_size += PB._encoded_size(x.slice_endpoint_ids, 3))
    !isempty(x.slice_constraints) && (encoded_size += PB._encoded_size(x.slice_constraints, 4))
    !isempty(x.slice_service_ids) && (encoded_size += PB._encoded_size(x.slice_service_ids, 5))
    !isempty(x.slice_subslice_ids) && (encoded_size += PB._encoded_size(x.slice_subslice_ids, 6))
    !isnothing(x.slice_status) && (encoded_size += PB._encoded_size(x.slice_status, 7))
    !isnothing(x.slice_config) && (encoded_size += PB._encoded_size(x.slice_config, 8))
    !isnothing(x.slice_owner) && (encoded_size += PB._encoded_size(x.slice_owner, 9))
    !isnothing(x.timestamp) && (encoded_size += PB._encoded_size(x.timestamp, 10))
    return encoded_size
end

struct DeviceEvent
    event::Union{Nothing,Event}
    device_id::Union{Nothing,DeviceId}
    device_config::Union{Nothing,DeviceConfig}
end
PB.default_values(::Type{DeviceEvent}) = (;event = nothing, device_id = nothing, device_config = nothing)
PB.field_numbers(::Type{DeviceEvent}) = (;event = 1, device_id = 2, device_config = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceEvent})
    event = Ref{Union{Nothing,Event}}(nothing)
    device_id = Ref{Union{Nothing,DeviceId}}(nothing)
    device_config = Ref{Union{Nothing,DeviceConfig}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, event)
        elseif field_number == 2
            PB.decode!(d, device_id)
        elseif field_number == 3
            PB.decode!(d, device_config)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceEvent(event[], device_id[], device_config[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceEvent)
    initpos = position(e.io)
    !isnothing(x.event) && PB.encode(e, 1, x.event)
    !isnothing(x.device_id) && PB.encode(e, 2, x.device_id)
    !isnothing(x.device_config) && PB.encode(e, 3, x.device_config)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceEvent)
    encoded_size = 0
    !isnothing(x.event) && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.device_id) && (encoded_size += PB._encoded_size(x.device_id, 2))
    !isnothing(x.device_config) && (encoded_size += PB._encoded_size(x.device_config, 3))
    return encoded_size
end

struct Device
    device_id::Union{Nothing,DeviceId}
    name::String
    device_type::String
    device_config::Union{Nothing,DeviceConfig}
    device_operational_status::DeviceOperationalStatusEnum.T
    device_drivers::Vector{DeviceDriverEnum.T}
    device_endpoints::Vector{EndPoint}
    components::Vector{Component}
    controller_id::Union{Nothing,DeviceId}
end
PB.default_values(::Type{Device}) = (;device_id = nothing, name = "", device_type = "", device_config = nothing, device_operational_status = DeviceOperationalStatusEnum.DEVICEOPERATIONALSTATUS_UNDEFINED, device_drivers = Vector{DeviceDriverEnum.T}(), device_endpoints = Vector{EndPoint}(), components = Vector{Component}(), controller_id = nothing)
PB.field_numbers(::Type{Device}) = (;device_id = 1, name = 2, device_type = 3, device_config = 4, device_operational_status = 5, device_drivers = 6, device_endpoints = 7, components = 8, controller_id = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Device})
    device_id = Ref{Union{Nothing,DeviceId}}(nothing)
    name = ""
    device_type = ""
    device_config = Ref{Union{Nothing,DeviceConfig}}(nothing)
    device_operational_status = DeviceOperationalStatusEnum.DEVICEOPERATIONALSTATUS_UNDEFINED
    device_drivers = PB.BufferedVector{DeviceDriverEnum.T}()
    device_endpoints = PB.BufferedVector{EndPoint}()
    components = PB.BufferedVector{Component}()
    controller_id = Ref{Union{Nothing,DeviceId}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, device_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            device_type = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, device_config)
        elseif field_number == 5
            device_operational_status = PB.decode(d, DeviceOperationalStatusEnum.T)
        elseif field_number == 6
            PB.decode!(d, wire_type, device_drivers)
        elseif field_number == 7
            PB.decode!(d, device_endpoints)
        elseif field_number == 8
            PB.decode!(d, components)
        elseif field_number == 9
            PB.decode!(d, controller_id)
        else
            PB.skip(d, wire_type)
        end
    end
    return Device(device_id[], name, device_type, device_config[], device_operational_status, device_drivers[], device_endpoints[], components[], controller_id[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Device)
    initpos = position(e.io)
    !isnothing(x.device_id) && PB.encode(e, 1, x.device_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.device_type) && PB.encode(e, 3, x.device_type)
    !isnothing(x.device_config) && PB.encode(e, 4, x.device_config)
    x.device_operational_status != DeviceOperationalStatusEnum.DEVICEOPERATIONALSTATUS_UNDEFINED && PB.encode(e, 5, x.device_operational_status)
    !isempty(x.device_drivers) && PB.encode(e, 6, x.device_drivers)
    !isempty(x.device_endpoints) && PB.encode(e, 7, x.device_endpoints)
    !isempty(x.components) && PB.encode(e, 8, x.components)
    !isnothing(x.controller_id) && PB.encode(e, 9, x.controller_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Device)
    encoded_size = 0
    !isnothing(x.device_id) && (encoded_size += PB._encoded_size(x.device_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.device_type) && (encoded_size += PB._encoded_size(x.device_type, 3))
    !isnothing(x.device_config) && (encoded_size += PB._encoded_size(x.device_config, 4))
    x.device_operational_status != DeviceOperationalStatusEnum.DEVICEOPERATIONALSTATUS_UNDEFINED && (encoded_size += PB._encoded_size(x.device_operational_status, 5))
    !isempty(x.device_drivers) && (encoded_size += PB._encoded_size(x.device_drivers, 6))
    !isempty(x.device_endpoints) && (encoded_size += PB._encoded_size(x.device_endpoints, 7))
    !isempty(x.components) && (encoded_size += PB._encoded_size(x.components, 8))
    !isnothing(x.controller_id) && (encoded_size += PB._encoded_size(x.controller_id, 9))
    return encoded_size
end

struct Service
    service_id::Union{Nothing,ServiceId}
    name::String
    service_type::ServiceTypeEnum.T
    service_endpoint_ids::Vector{EndPointId}
    service_constraints::Vector{Constraint}
    service_status::Union{Nothing,ServiceStatus}
    service_config::Union{Nothing,ServiceConfig}
    timestamp::Union{Nothing,Timestamp}
end
PB.default_values(::Type{Service}) = (;service_id = nothing, name = "", service_type = ServiceTypeEnum.SERVICETYPE_UNKNOWN, service_endpoint_ids = Vector{EndPointId}(), service_constraints = Vector{Constraint}(), service_status = nothing, service_config = nothing, timestamp = nothing)
PB.field_numbers(::Type{Service}) = (;service_id = 1, name = 2, service_type = 3, service_endpoint_ids = 4, service_constraints = 5, service_status = 6, service_config = 7, timestamp = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Service})
    service_id = Ref{Union{Nothing,ServiceId}}(nothing)
    name = ""
    service_type = ServiceTypeEnum.SERVICETYPE_UNKNOWN
    service_endpoint_ids = PB.BufferedVector{EndPointId}()
    service_constraints = PB.BufferedVector{Constraint}()
    service_status = Ref{Union{Nothing,ServiceStatus}}(nothing)
    service_config = Ref{Union{Nothing,ServiceConfig}}(nothing)
    timestamp = Ref{Union{Nothing,Timestamp}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, service_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            service_type = PB.decode(d, ServiceTypeEnum.T)
        elseif field_number == 4
            PB.decode!(d, service_endpoint_ids)
        elseif field_number == 5
            PB.decode!(d, service_constraints)
        elseif field_number == 6
            PB.decode!(d, service_status)
        elseif field_number == 7
            PB.decode!(d, service_config)
        elseif field_number == 8
            PB.decode!(d, timestamp)
        else
            PB.skip(d, wire_type)
        end
    end
    return Service(service_id[], name, service_type, service_endpoint_ids[], service_constraints[], service_status[], service_config[], timestamp[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Service)
    initpos = position(e.io)
    !isnothing(x.service_id) && PB.encode(e, 1, x.service_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    x.service_type != ServiceTypeEnum.SERVICETYPE_UNKNOWN && PB.encode(e, 3, x.service_type)
    !isempty(x.service_endpoint_ids) && PB.encode(e, 4, x.service_endpoint_ids)
    !isempty(x.service_constraints) && PB.encode(e, 5, x.service_constraints)
    !isnothing(x.service_status) && PB.encode(e, 6, x.service_status)
    !isnothing(x.service_config) && PB.encode(e, 7, x.service_config)
    !isnothing(x.timestamp) && PB.encode(e, 8, x.timestamp)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Service)
    encoded_size = 0
    !isnothing(x.service_id) && (encoded_size += PB._encoded_size(x.service_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    x.service_type != ServiceTypeEnum.SERVICETYPE_UNKNOWN && (encoded_size += PB._encoded_size(x.service_type, 3))
    !isempty(x.service_endpoint_ids) && (encoded_size += PB._encoded_size(x.service_endpoint_ids, 4))
    !isempty(x.service_constraints) && (encoded_size += PB._encoded_size(x.service_constraints, 5))
    !isnothing(x.service_status) && (encoded_size += PB._encoded_size(x.service_status, 6))
    !isnothing(x.service_config) && (encoded_size += PB._encoded_size(x.service_config, 7))
    !isnothing(x.timestamp) && (encoded_size += PB._encoded_size(x.timestamp, 8))
    return encoded_size
end

struct SliceList
    slices::Vector{Slice}
end
PB.default_values(::Type{SliceList}) = (;slices = Vector{Slice}())
PB.field_numbers(::Type{SliceList}) = (;slices = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SliceList})
    slices = PB.BufferedVector{Slice}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, slices)
        else
            PB.skip(d, wire_type)
        end
    end
    return SliceList(slices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SliceList)
    initpos = position(e.io)
    !isempty(x.slices) && PB.encode(e, 1, x.slices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SliceList)
    encoded_size = 0
    !isempty(x.slices) && (encoded_size += PB._encoded_size(x.slices, 1))
    return encoded_size
end

struct DeviceList
    devices::Vector{Device}
end
PB.default_values(::Type{DeviceList}) = (;devices = Vector{Device}())
PB.field_numbers(::Type{DeviceList}) = (;devices = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeviceList})
    devices = PB.BufferedVector{Device}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, devices)
        else
            PB.skip(d, wire_type)
        end
    end
    return DeviceList(devices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeviceList)
    initpos = position(e.io)
    !isempty(x.devices) && PB.encode(e, 1, x.devices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeviceList)
    encoded_size = 0
    !isempty(x.devices) && (encoded_size += PB._encoded_size(x.devices, 1))
    return encoded_size
end

struct TopologyDetails
    topology_id::Union{Nothing,TopologyId}
    name::String
    devices::Vector{Device}
    links::Vector{Link}
    optical_links::Vector{OpticalLink}
end
PB.default_values(::Type{TopologyDetails}) = (;topology_id = nothing, name = "", devices = Vector{Device}(), links = Vector{Link}(), optical_links = Vector{OpticalLink}())
PB.field_numbers(::Type{TopologyDetails}) = (;topology_id = 1, name = 2, devices = 3, links = 4, optical_links = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TopologyDetails})
    topology_id = Ref{Union{Nothing,TopologyId}}(nothing)
    name = ""
    devices = PB.BufferedVector{Device}()
    links = PB.BufferedVector{Link}()
    optical_links = PB.BufferedVector{OpticalLink}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, topology_id)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, devices)
        elseif field_number == 4
            PB.decode!(d, links)
        elseif field_number == 5
            PB.decode!(d, optical_links)
        else
            PB.skip(d, wire_type)
        end
    end
    return TopologyDetails(topology_id[], name, devices[], links[], optical_links[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TopologyDetails)
    initpos = position(e.io)
    !isnothing(x.topology_id) && PB.encode(e, 1, x.topology_id)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.devices) && PB.encode(e, 3, x.devices)
    !isempty(x.links) && PB.encode(e, 4, x.links)
    !isempty(x.optical_links) && PB.encode(e, 5, x.optical_links)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TopologyDetails)
    encoded_size = 0
    !isnothing(x.topology_id) && (encoded_size += PB._encoded_size(x.topology_id, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.devices) && (encoded_size += PB._encoded_size(x.devices, 3))
    !isempty(x.links) && (encoded_size += PB._encoded_size(x.links, 4))
    !isempty(x.optical_links) && (encoded_size += PB._encoded_size(x.optical_links, 5))
    return encoded_size
end

struct ServiceList
    services::Vector{Service}
end
PB.default_values(::Type{ServiceList}) = (;services = Vector{Service}())
PB.field_numbers(::Type{ServiceList}) = (;services = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ServiceList})
    services = PB.BufferedVector{Service}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, services)
        else
            PB.skip(d, wire_type)
        end
    end
    return ServiceList(services[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ServiceList)
    initpos = position(e.io)
    !isempty(x.services) && PB.encode(e, 1, x.services)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ServiceList)
    encoded_size = 0
    !isempty(x.services) && (encoded_size += PB._encoded_size(x.services, 1))
    return encoded_size
end

# TODO: SERVICE
#    ContextService
